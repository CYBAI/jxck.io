# [service worker] Service Worker 内でできないこと

## Intro

Service Worker は少し特殊な環境であるため、できることできないことを正しく把握しておく必要がある。


## DOMParser

Service Worker 内では、 DOM に触ることができないという制約があるが、それは単に `window.documents` に触れないだけでなく、現状では DOMParser という、文字列を DOM として Parse する API にも触ることができない。

DOMParser API を使うことができれば、いわゆる HTML の文字列をパースし、 DOM オブジェクトの Tree を構築できる。

これが使えたならば以下のようなことが可能である。


### RSS の解析

サイト内の URL のリストを元に、 cache にレスポンスを保存することがよくある。
この URL のリストだが、例えばブログであれば、各エントリの URL や、差新の更新情報を知りたくなる。
また、複数ある場合 `cache.addAll()` に直接書いてしまってはメンテナンスがしづらいし、ソースのキャッシュ効率も下がる。

```js
self.addEventListener('install', (e) => {
  e.waitUnitl(caches.open('v1').then(cache) => {
    cache.addAll([
      '/url1', '/url2', '/url3', '/url4', // ここはどこかから取得したい
    ]);
  });
});
```

さて、 Web にはそのサイトが含むコンテンツの、最新の URL リストを提供する仕組みが有る。
ずばり **RSS** だ。

キャッシュするコンテンツの URL を知るために新たな JSON ファイルを更新しても良いが、すでに RSS が配信されていればそれをそのまま利用できる。

DOMParser が使えれば、 RSS をパースし、 querySelector でリンクだけを取得できるが、現状は残念ながら自分で別途 XML パーサを読み込む必要がある。


### Service Worker Rendering

SPA として作られたアプリを、ある状態で HTML 化した静的コンテンツとしてレスポンスに載せるテクニックは Server Side Rendering(SSR) と呼ばれる。
これは、クローラ(SEO)対策やキャッシュ効率、アドレス可能性の向上のために使われる。

これと等価なことを Service Worker 内で行うという発想である。

これは以下のようなケースで有用と考えられる。

TODO:
SSR に対応していない
- SPA を構成するのに必要な全てのリソースはあるが、レンダリングされた結果を取得してない
- 一方で、ログインを伴うようなサイトでは、 URL が同じでもユーザ毎に異なる情報が含まれていることで、キャッシュが難しいページもある。

もし Service Worker 内でレンダリングができると、ユーザ毎に異なる情報が含まれた状態で生成される静的コンテンツでも、容易にキャッシュできる。







本来的な「DOM に触れない」の主旨は、 window 上に構築された DOM の直接的な操作を制限するという主旨であるため、そこと切り離された DOMParser などには触れても良さそうだ。
実装の問題であるなら、いつか解決すれば、先に上げたようなことが実現できるため、可能性が広がると考える。


## Lifecycle



## Storage



