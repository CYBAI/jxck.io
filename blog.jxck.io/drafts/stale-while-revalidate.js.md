# [service worker][performance] stale-while-revalidate の service worker 実装

本サイトに Service Worker を導入し、リソースのキャッシュによる最適化を実施した。

この最適化は、キャッシュの鮮度を極力損ねないために、ロード完了後にキャッシュをリフレッシュし、実際にキャッシュストレージからは一回しか取り出さない方式を採用した。

本エントリではこれを One Time Cache と呼ぶ。

またそれをライブラリとして切り出したため、入れるだけでサイトのキャッシュが効くようになる。

合わせて、オフライン対応にもなる。





## Service Worker

Service Worker については、もう特に解説は必要ないだろう。

今回はこれを登録し、透過プロキシとして動作させる。

透過として扱うことで、これが利用可能なブラウザでは閲覧が改善する一方、 SW が使えないブラウザや、 JS が利用できない AMP 対応ページでの動作も、閲覧が可能になる。


## One Time Cache

Service Worker の用途の一つに、キャッシュへの保存がある。

onfetch イベントを補足し、リクエストとレスポンスの対を Cache に保存することで、以降のリクエストではそのキャッシュから中身を取り出す。


```js



```

ただし、このキャッシュの内容はブラウザキャッシュとは別であるため、スクリプト内で管理する必要がある。

キャッシュが効くことでコンテンツの取得を高速化できる一方で、キャッシュの中身が古くなると、サイト側でコンテンツを更新しても、ユーザには古い情報が表示されてしまう。

そこで本サイトでは、キャッシュのライフサイクルを以下のように設計した。

1. キャッシュが空の場合 fetch する。それをブラウザに返し、キャッシュに追加する。
2. キャッシュがある場合は、それを返し、裏で fetch してキャッシュを更新する。

表示を高速化するため、一度だけキャッシュを使い、裏でそれをリフレッシュする。

これによって、リアルタイムに変更されていくリソースでも、キャッシュがある場合は表示が早くなり、そのキャッシュも、すぐに更新することができる。

本サイトは、読むのに多少時間をとるコンテンツが中心であるため、ユーザが滞在している時間に裏で fetch を行うという戦略である。

ページを表示すれば必ず fetch が走るため、同じキャッシュが使われるのは高々一回となるはずである。

本サイトでは、便宜上これをワンタイムキャッシュと呼ぶことにする。

これは、ブラウザの Cache-Control や ETag では実現が難し処理である。




## Claim

Service Worker は、最初の画面遷移時にインストールされ、通常は次の遷移で有効になる。

しかし、最初のページから次のページへ遷移する時点で、次のページのレスポンスはキャッシュしておきたい。

そこで、すぐにそのページからの fetch イベントをキャプチャできるように、 Service Worker がインストールされたら、すぐにページをコントロール下に置くようにする。

それを実現する API として、 Claim が提供されているためこれを利用する。
