# [expect-ct][hpkp][ct][security] CT の仕組みと HPKP から Expect-CT への移行

## Intro

本サイトは HPKP (public-key-pins-report-only) に対応している。

しかし HPKP は、同等と問題を解決する別の仕様として Expect-CT の策定/実装が進んでいる。

本サイトの Expect-CT 対応は、 h2o の実装待ちということになったが、せっかくなので CT の仕組みについて解説する。


## 「CA は信用できるのか?」問題

HTTPS 化が叫ばれる昨今、トラストアンカーとしての CA の責務は増している。

我々が依存する PKI は、 「CA は信用できる」という前提のもとに成り立っているため、 CA はその信用を担保するために堅牢なシステムを構築することを求められる。

しかし、最近 CA が **証明書を誤発行する** などといった、この安全の前提を崩すような事態が複数発生している。

例えば `google.com` の証明書を、 `google.com` の管理者に知られずに、正規の CA に発酵させることができたとする。

あるユーザ Alice へ MITM を成立させたら、 Alice への `https://google.com` のレスポンスを、取得した証明書ですり替えることができる。

Alice のブラウザはそのレスポンスが信頼された `google.com` からのものであると表示し、 URL バーも緑になってしまう。

Google は自分の知らないところで `google.com` の証明書が発行されていないことを祈るしか無い。


## HPKP

Google が CA から発行を受けた証明書と、攻撃者が CA に誤発行させた証明書は、別のものである。

つまり、ハッシュを取得すれば 2 つの値は変わるはずだ。

そこで、 Google は自身が所有する証明書のハッシュ値をレスポンスヘッダに付与し、ブラウザに確認させる方法を考えた。

MITM によってすり替えられたレスポンスに使用された証明書は、 Google が付与したハッシュと合わない。

これにより、ブラウザは証明書が意図したものと違うことに気づくことができるのである。

これが HPKP (HTTP Public Key Pinning) の基本的な考え方であった。

本サイトも、実験的にこれを適用していた。

[Public Key Pinning for HTTP(HPKP) 対応と report-uri.io でのレポート収集](https://blog.jxck.io/entries/2016-04-09/public-key-pinning.html)


しかし、このヘッダは証明書の失効/更新時に、ハッシュが不整合を起こすのを防ぐ必要があり、運用が難しかった。

そこで、並行して行われていた CT という仕組みを応用し、より運用負荷が低い形で同等のことを実現する方法が提案された。

それが CT と Expect-CT ヘッダである。


## CT

CT (Certificate Transparency) は、その視点で言えば「CA を監視する」技術と言えなくもない。

ちなみに、「証明書透かし」などと訳された文書もあるが、いわゆる「電子透かし」とは別のものと思った方が良いだろう。

まず、 CA は証明書を発行するとき、その「証明書を発行した」という事実を CT Log と呼ばれるログサーバに登録する。

先の例で、 Google が恐れていたのは「自分たちが知らないところで `google.com` の証明書が発行されること」だ。

そこで Google はこの CT Log を全て監視することで、 `google.com` 証明書の発行 Log を知ることができる。

自分たちが把握している発行が Log に登録されるのはもちろん問題ないし、把握していない Log が登録されれば、攻撃などで CA が誤発行を起こしたことがすぐにわかる。

攻撃は、発生していることがわかれば、対応ができる。これは、わからなかったころと比べるとかなりの進歩だ。


## CT Log

全ての CT Log は、パブリックな URL が公開され、 HTTPS でアクセスし GET/POST で操作できる。

これにより、だれでも CT Log を監視/検証することができる。

Log は Merkle Tree Hashes を用いて構築されており **追記** しか出来ないことが暗号的に保証されている。

CA や CT Log の admin ですら、削除、更新、挿入などは行えず、ログが改ざんされていないことを前提とできるのである。

また、 CT Log を登録すると、ログサーバからは SCT (Signed Certificate Timestamp) という値が発行される。

この SCT 値が重要だが、用途については後述する。


## CT Log の強制

しかし、 CA がきちんとログを登録していることが前提となるため、もし CA がログを登録していなければ監視は意味がない。

どうやって CA に CT Log を登録させるか。

ブラウザは、 SCT を取得することができれば、それを元にログを検証し、その証明書がきちんとログに登録されているかを確認することができる。

ブラウザが SCT を取得する方法は 3 つある。

- 証明書に埋め込む
- TLS ハンドシェイクに埋め込む
- OCSP に埋め込む

この中で Chrome は、 EV 証明書については、 SCT を含むことを必須としている。

SCT が無い場合は、例えそれが、従来の検証方法で有効な EV 証明書であっても、 Chrome はそれを認めなくなる。

すると、自社の発行する EV が Chrome では使えないという状況を防ぐために、 CA は EV を発行する際に必ず Log を登録せざるをえなくなる。

これによって、証明書の誤発行を監視するエコシステムが形成されるのだ。


## 証明書監視のエコシステム

ここでは先ほどと同様、 Google が管理する `google.com` の EV 証明書を例に、ケースごとに何が発生するのかを整理する。


### 証明書が誤発行されたが Log は登録されている

Google は、 `google.com` の EV 証明書が、自分たちの知らないところで勝手に発行されていないかを監視している。

したがって、監視している Log サーバに Log が登録されれば、誤発行をすぐに発見し、対策が行える。


### 証明書が誤発行され、 Log が登録されていない

Log が登録されていないため、 SCT は取得されず、結果証明書には SCT が埋め込まれていない。

Chrome は SCT の無い EV 証明書を認めないため、その証明書がおかしいものであることに気づくことができる。

ただし、 SCT に対応していないブラウザでは、その証明書は有効となる。


### 証明書が誤発行され、 Log が登録されたが、後からログを消去/改ざんした

CT のログは Merkle Tree Hashes を用いているため、ログを消そうとすると不整合が発生する。

外部からログを監視/検証しているロールが、それに気づくことができる。


### 証明書が誤発行されたが、ログを登録せず、証明書には別の SCT を埋め込んだ

SCT は証明書そのものの値をハッシュのシードとして含んでいる。

従って SCT を検証するブラウザが、おかしいことに気づくことができる。


##











## Expect-CT Header

前述の通り、 SCT を取得する方法は 3 つある。

- 証明書に埋め込む
- TLS ハンドシェイクに埋め込む
- OCSP に埋め込む

もし Chrome のように証明書に対して、 SCT を強制する仕様を入れない場合を考える。

SCT が強制されていないならば、 CT ログを登録せずに誤発行させた証明書は、 SCT をどこにも埋め込まなければ使えてしまう。

そこで、コンテンツ側から「**このコンテンツは CT に対応した証明書で提供される**」ということを明示する方法が提案された。

これが `Expect-CT` ヘッダだ。

これにより、ブラウザの証明書ポリシーとは別に、コンテンツ提供者が CT を強制させることができるのだ。


### directives

Expect-CT のディレクティブはシンプルだ。基本的には CSP と同じような設計になっている。

- `enforce`:  SCT のチェックをブラウザに強制させる
- `report-uri`: CSP レポートの送信先
- `maz-age`: 有効期限


重要な点は、 **Expect-CT 自体が SCT の値を含むわけではない** ということだ。






https://tools.ietf.org/html/draft-ietf-httpbis-expect-ct-02
