# [expect-ct][hpkp][ct][security] CT の仕組みと HPKP から Expect-CT への移行

## Intro

本サイトで対応していた HPKP (public-key-pins-report-only) に対応していた。

しかし HPKP は、同等と問題を解決する別の仕様として Expect-CT の策定/実装が進んでいる。

本サイトの Expect-CT 対応と合わせて CT の仕組みについて解説する。


## 「CA は信用できるのか?」問題

HTTPS 化が叫ばれる昨今、トラストアンカとしての CA の責務は増している。

我々が依存する PKI は、 「CA は信用できる」という前提のもとに成り立っているため、 CA はその信用を担保するために堅牢なシステムを構築することを求められる。

しかし、最近 CA が **証明書を誤発行する** などといった、この安全の前提を崩すような自体が複数発生している。

例えば `google.com` の証明書を、正規の CA に、 `google.com` の管理者に知られずに発行することができたとする。

あるユーザ Alice へ MITM を成立させたら、 Alice への `https://google.com` のレスポンスを先ほど取得した証明書ですり替えることができる。

Alice のブラウザはそのレスポンスが信頼された `google.com` からのものであると表示し、 URL バーも緑になってしまう。

Google は自分の知らないところで `google.com` の証明書が発行されていないことを祈るしか無い。


## HPKP

Google が CA から発行を受けた証明書と、攻撃者が CA に誤発行させた証明書は、別のものである。

つまり、ハッシュを取得すれば 2 つの値は変わるはずだ。

そこで、 Google は自身が所有する証明書のハッシュ値をレスポンスヘッダに付与し、ブラウザに確認させる方法を考えた。

MITM によってすり替えられたレスポンスに使用された証明書は、 Google が付与したハッシュと合わない。

これにより、ブラウザは証明書が意図したものと違うことに気づくことができるのである。

これが HPKP (HTTP Public Key Pinning) の基本的な考え方であった。

本サイトも、実験的にこれを適用していた。

[Public Key Pinning for HTTP(HPKP) 対応と report-uri.io でのレポート収集](https://blog.jxck.io/entries/2016-04-09/public-key-pinning.html)


しかし、このヘッダは証明書の失効/更新時に、ハッシュが不整合を起こすのを防ぐ必要があり、運用が難しかった。

そこで、並行して行われていた CT という仕組みを応用し、より運用負荷が低い形で同等のことを実現する方法が提案された。

それが CT と Expect-CT ヘッダである。


## CT

CT (Certificate Transparency) は、その視点で言えば「CA を監視する」技術と言えなくもない。

ちなみに、誤訳で「証明書透かし」などと訳された文書もあるが、いわゆる「電子透かし」は関係ない。

まず、 CA は証明書を発行するとき、その「証明書を発行した」という事実を CT Log と呼ばれるログサーバに登録する。

先の例で、 Google が恐れていたのは「自分たちが知らないところで `google.com` の証明書が発行されること」だ。

これは、 Google がこの CT Log を全て監視することで解決できる。

自分たちが把握している発行が Log に登録されるのはもちろん問題ないし、把握していない Log が登録されれば、攻撃などで CA が誤発行を起こしたことがすぐにわかる。

攻撃は、発生していることがわかれば、対応ができる。これは、わからなかったころと比べるとかなりの変化だ。


## CT Log

CT の Log は、 Merkle Tree Hashes を用いて構築されている。

また、全ての Log は、パブリックな URL が公開され、 HTTPS でアクセスし GET/POST で操作できる。

これにより、 Merkle Tree のハッシュの整合性は誰でも検証可能であり、結果 **追記** しか出来ないことが暗号的に保証されている。

CA や CT Log の admin ですら、削除、更新、挿入などは行えず、ログが改ざんされていないことを前提とできるのである。

また、 CT Log を登録すると、ログサーバからは SCT (Signed Certificate Timestamp) という値が発行される。

この SCT 値が重要だが、用途については後述する。



## CT Log の強制

しかし、 CA がきちんとログを登録していることが前提となるため、もし CA がログを登録していなければ監視は意味がない。

どうやって CA に CT Log を登録させるか。

ブラウザは、 SCT を取得することができれば、それを元にログを検証し、その証明書がきちんとログに登録されているかを確認することができる。

ブラウザが SCT を取得する方法は 3 つある。

- 証明書に埋め込む
- TLS ハンドシェイクに埋め込む
- OCSP に埋め込む

この中で Chrome は、 EV 証明書については、 SCT を含むことを必須としている。

SCT が無い場合は、例えそれが、従来の検証方法で有効な EV 証明書であっても、 Chrome はそれを認めなくなる。

すると、 EV を発行する CA は必ず Log サーバに登録せざるをえなくなる。

これによって、証明書の誤発行を監視するエコシステムが形成されるのだ。


## 証明書監視のエコシステム

ここでは先ほどと同様、 Google が管理する google.com の EV 証明書を例に、ケースごとに何が発生するのかを解説する。


### 証明書が誤発行されたが Log は登録されている

Google は、 google.com の EV 証明書が、自分たちの知らないところで勝手に発行されていないかを監視している。

したがって、監視している Log サーバに Log が登録されれば、その自体をすぐに発見し、対策ができる。


### 証明書が誤発行され、 Log が登録されていない

Log が登録されていないため、 SCT は取得されず、結果証明書には SCT が埋め込まれていない。

Chrome は SCT の無い証明書を認めないため、その証明書がおかしいものであることに気づくことができる。

SCT に対応していないブラウザでは、有効な証明書としてみることができる。


### 証明書が誤発行され、 Log が登録されたが、後からログを消去/改ざんした

CT のログは Merkle Tree Hashes を用いているため、ログを消そうとすると不整合が発生する。

外部からログを監視/検証しているロールが、それに気づくことができる。


### 証明書が誤発行されたが、ログを登録せず、証明書には別の SCT を埋め込んだ

SCT は証明書そのものの値をハッシュのシードとして含んでいるため、 SCT を検証するブラウザが、おかしいことに気づく。


##











## Expect-CT Header





https://tools.ietf.org/html/draft-ietf-httpbis-expect-ct-02
