# The Secure Real-time Transport Protocol (SRTP)

## Header

- Network Working Group
- Request for Comments: 3711
- Category: Standards Track
- M. Baugher
- D. McGrew Cisco Systems, Inc.
- M. Naslund
- E. Carrara
- K. Norrman Ericsson Research
- March 2004

## このメモの位置付け (Status of this Memo)

This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the "Internet Official Protocol Standards" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」(STD 1)の最新版を参照してください。このメモの配布は無制限です。

著作権について (Copyright Notice)

Copyright (C) The Internet Society (2004). All Rights Reserved.
著作権(C)インターネット協会(2004)。全著作権所有。

## 抽象 (Abstract)

This document describes the Secure Real-time Transport Protocol (SRTP), a profile of the Real-time Transport Protocol (RTP), which can provide confidentiality, message authentication, and replay protection to the RTP traffic and to the control traffic for RTP, the Real-time Transport Control Protocol (RTCP).
この文書では、セキュアリアルタイム転送プロトコル(SRTP)、 RTP トラフィックにと RTP 用の制御トラフィックに機密性、メッセージ認証、および再生保護を提供することができ、リアルタイムトランスポートプロトコル(RTP)のプロファイルを記載しますリアルタイムトランスポート制御プロトコル(RTCP)。

## Table of Contents

1. Introduction ............................................ 3
    1. Notational Conventions .............................. 3
2. Goals and Features ...................................... 4
    1. Features ............................................ 5
3. SRTP Framework .......................................... 5
    1. Secure RTP .......................................... 6
    2. SRTP Cryptographic Contexts.......................... 7
        1. Transform-independent parameters ................ 8
        2. Transform-dependent parameters .................. 10
        3. Mapping SRTP Packets to Cryptographic Contexts .. 10
    3. SRTP Packet Processing .............................. 11
        1. Packet Index Determination, and ROC, s_l Update . 13
        2. Replay Protection................................ 15
    4. Secure RTCP ......................................... 15
4. Pre-Defined Cryptographic Transforms .................... 19
    1. Encryption .......................................... 19
        1. AES in Counter Mode.............................. 21
        2. AES in f8-mode .................................. 22
        3. NULL Cipher...................................... 25
    2. Message Authentication and Integrity ................ 25
        1. HMAC-SHA1........................................ 25
    3. Key Derivation ...................................... 26
        1. Key Derivation Algorithm ........................ 26
        2. SRTCP Key Derivation ............................ 28
        3. AES-CM PRF ...................................... 28
5. Default and mandatory-to-implement Transforms............ 28
    1. Encryption: AES-CM and NULL.......................... 29
    2. Message Authentication/Integrity: HMAC-SHA1.......... 29
    3. Key Derivation: AES-CM PRF .......................... 29
6. Adding SRTP Transforms .................................. 29
7. Rationale................................................ 30
    1. Key derivation ...................................... 30
    2. Salting key.......................................... 30
    3. Message Integrity from Universal Hashing ............ 31
    4. Data Origin Authentication Considerations............ 31
    5. Short and Zero-length Message Authentication ........ 32
8. Key Management Considerations............................ 33
    1. Re-keying............................................ 34
        1. Use of the &lt;From, To&gt; for re-keying........ 34
    2. Key Management parameters............................ 35
9. Security Considerations.................................. 37
    1. SSRC collision and two-time pad...................... 37
    2. Key Usage............................................ 38
    3. Confidentiality of the RTP Payload .................. 39
    4. Confidentiality of the RTP Header.................... 40
    5. Integrity of the RTP payload and header.............. 40
        1. Risks of Weak or Null Message Authentication..... 42
        2. Implicit Header Authentication .................. 43
10. Interaction with Forward Error Correction mechanisms.... 43
11. Scenarios .............................................. 43
    1. Unicast.............................................. 43
    2. Multicast (one sender) .............................. 44
    3. Re-keying and access control ........................ 45
    4. Summary of basic scenarios .......................... 46
12. IANA Considerations..................................... 46
13. Acknowledgements ....................................... 47
14. References ............................................. 47
    1. Normative References ................................ 47
    2. Informative References .............................. 48
15. Appendix A: Pseudocode for Index Determination ......... 51
16. Appendix B: Test Vectors ............................... 51
    1. B.1. AES-f8 Test Vectors............................. 51
    2. B.2. AES-CM Test Vectors............................. 52
    3. B.3. Key Derivation Test Vectors..................... 53
17. Authors' Addresses ..................................... 55
18. Full Copyright Statement ............................... 56

## 1.はじめに (1. Introduction)

This document describes the Secure Real-time Transport Protocol (SRTP), a profile of the Real-time Transport Protocol (RTP), which can provide confidentiality, message authentication, and replay protection to the RTP traffic and to the control traffic for RTP, RTCP (the Real-time Transport Control Protocol) [RFC3350].
この文書では、セキュアリアルタイム転送プロトコル(SRTP)、 RTP トラフィックにと RTP 用の制御トラフィックに機密性、メッセージ認証、および再生保護を提供することができ、リアルタイムトランスポートプロトコル(RTP)のプロファイルを記載します RTCP(リアルタイムトランスポート制御プロトコル)[RFC3350]。

SRTP provides a framework for encryption and message authentication of RTP and RTCP streams (Section 3). SRTP defines a set of default cryptographic transforms (Sections 4 and 5), and it allows new transforms to be introduced in the future (Section 6). With appropriate key management (Sections 7 and 8), SRTP is secure (Sections 9) for unicast and multicast RTP applications (Section 11).
SRTP は、 RTP と RTCP ストリーム(第 3)の暗号化とメッセージ認証のためのフレームワークを提供します。 SRTP は、デフォルトの暗号化変換(セクション 4 及び 5)のセットを定義し、それが新たな変換が将来(第 6)に導入されることを可能にします。適切なキー管理(セクション 7 および 8)と、 SRTP は、ユニキャストおよびマルチキャスト RTP アプリケーション(セクション 11)のために(セクション 9)安全です。

SRTP can achieve high throughput and low packet expansion. SRTP proves to be a suitable protection for heterogeneous environments (mix of wired and wireless networks). To get such features, default transforms are described, based on an additive stream cipher for encryption, a keyed-hash based function for message authentication, and an "implicit" index for sequencing/synchronization based on the RTP sequence number for SRTP and an index number for Secure RTCP (SRTCP).
SRTP は、高いスループットと低パケット拡張を実現することができます。 SRTP は、異機種環境(有線及び無線ネットワークの混在)に適した保護であることが分かります。このような特徴を取得するには、デフォルトの変換は、暗号化のための添加剤のストリーム暗号に基づいて、説明されている、メッセージ認証のための鍵付きハッシュベースの機能、および SRTP とインデックスのための RTP シーケンス番号に基づいて、シーケンシング/同期のための「暗黙の」インデックスセキュア RTCP(SRTCP)の番号。

### 1.1 。表記規則 (1.1. Notational Conventions)

The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119]. The terminology conforms to [RFC2828] with the following exception. For simplicity we use the term "random" throughout the document to denote randomly or pseudo-randomly generated values. Large amounts of random bits may be difficult to obtain, and for the security of SRTP, pseudo-randomness is sufficient [RFC1750].
キーワード "MUST"、 "MUST NOT"、 "REQUIRED" は、 "NOT SHALL" "ものと" この文書では、 "SHOULD"、 "推奨" "NOT SHOULD"、 "MAY"、 "OPTIONAL" はにあります[RFC2119]に記載されているように解釈されます。用語は、以下の例外を除いて、[RFC2828]に準拠します。簡単にするために、我々は、ランダムに表したり、擬似ランダムに生成された値となる文書を通じて、「ランダム」という用語を使用します。ランダムビットの大量を得ることが困難であってもよく、 SRTP のセキュリティのために、擬似ランダムに十分[RFC1750]です。

By convention, the adopted representation is the network byte order, i.e., the left most bit (octet) is the most significant one. By XOR we mean bitwise addition modulo 2 of binary strings, and || denotes concatenation. In other words, if C = A || B, then the most significant bits of C are the bits of A, and the least significant bits of C equal the bits of B. Hexadecimal numbers are prefixed by 0x.
慣例により、採用表現は、一番左のビット(オクテット)は、最も重要な一つであり、すなわち、ネットワークバイトオーダーです。 XOR することにより、我々はバイナリ文字列のビット単位の加算モジュロ 2 を意味し、そして|| 連結を示しています。換言すれば、 C = A なら|| B 、次いで C の最上位ビットは、 A ビット、および C の最下位ビットは 0x を接頭辞 B. 16 進数のビットが等しいです。

The word "encryption" includes also use of the NULL algorithm (which in practice does leave the data in the clear).
単語「暗号化」も、(実際には明確にデータを残しません)NULL アルゴリズムの使用を含みます。

With slight abuse of notation, we use the terms "message authentication" and "authentication tag" as is common practice, even though in some circumstances, e.g., group communication, the service provided is actually only integrity protection and not data origin authentication.
いくつかの状況では、例えば、グループ通信は、提供されるサービスは、実際に整合性の保護だけではなく、データ発信元認証であっても、一般的に行われているとして、表記の若干の乱用で、我々は、用語「メッセージ認証」と「認証タグ」を使用します。

## 2.目標と特長 (2. Goals and Features)

The security goals for SRTP are to ensure:

SRTP のためのセキュリティゴールは次のとおりです。

- the confidentiality of the RTP and RTCP payloads, and
- the integrity of the entire RTP and RTCP packets, together with protection against replayed packets.

- RTP と RTCP ペイロードの機密性、
- 全体の RTP と RTCP パケットの完全性、およびリプレイパケットに対する保護機能を備えました。

These security services are optional and independent from each other, except that SRTCP integrity protection is mandatory (malicious or erroneous alteration of RTCP messages could otherwise disrupt the processing of the RTP stream).

これら SRTCP のセキュリティサービスは、 SRTP の完全性保護が必須(そうでない場合は RTP ストリームの処理を妨害する可能性が RTCP メッセージの悪意のあるまたは誤った変更)であること以外は、オプショナルであり互いに独立してる。

Other, functional, goals for the protocol are:

プロトコルのためのその他の機能、目的は次のとおりです。

- a framework that permits upgrading with new cryptographic transforms,
- low bandwidth cost, i.e., a framework preserving RTP header compression efficiency,

- 新しい暗号化変換とアップグレードが可能なフレームワーク、
- 低帯域幅のコスト、すなわち、 RTP ヘッダの圧縮効率を維持するフレームワーク、

and, asserted by the pre-defined transforms:

そして、事前に定義された変換によってアサートされる:

- a low computational cost,
- a small footprint (i.e., small code size and data memory for keying information and replay lists),
- limited packet expansion to support the bandwidth economy goal,
- independence from the underlying transport, network, and physical layers used by RTP, in particular high tolerance to packet loss and re-ordering.

- 低計算コスト
- 小さなフットプリント(すなわち、情報および再生リストをキーイングするための小さなコードサイズとデータメモリ)
- 帯域幅の経済目標をサポートするために、限られたパケットの拡張、
- パケット損失や再発注に特に高い耐性で、 RTP が使用する基礎となるトランスポート、ネットワーク、および物理層からの独立。

These properties ensure that SRTP is a suitable protection scheme for RTP/RTCP in both wired and wireless scenarios.

これらの特性は、 SRTP は有線と無線の両方のシナリオで RTP / RTCP に適した保護方式であることを確認します。

### 2.1. 特徴 (2.1. Features)

Besides the above mentioned direct goals, SRTP provides for some additional features. They have been introduced to lighten the burden on key management and to further increase security. They include:

上記の直接の目的のほかにも、 SRTP はいくつかの追加機能を提供します。これらは、鍵管理の負担を軽減し、さらにセキュリティを高めるために導入されています。以下を含みます。

- A single "master key" can provide keying material for confidentiality and integrity protection, both for the SRTP stream and the corresponding SRTCP stream. This is achieved with a key derivation function (see Section 4.3), providing "session keys" for the respective security primitive, securely derived from the master key.
- In addition, the key derivation can be configured to periodically refresh the session keys, which limits the amount of ciphertext produced by a fixed key, available for an adversary to cryptanalyze.
- "Salting keys" are used to protect against pre-computation and time-memory tradeoff attacks [MF00] [BS00].

- 一つの「マスターキー」は、両方の SRTP ストリームと対応する SRTCP ストリームのために、機密性と完全性保護のための鍵材料を提供することができます。 これは、 KDF (Section 4.3) から取得され、 master key からそれぞれのセキュリティ primitive に "session keys" を提供する。
- 加えて、鍵導出が周期的に攻撃者が cryptanalyze するために利用可能な固定キーによって生成された暗号文の量を制限するセッションキーをリフレッシュするように構成することができます。
- 加えて、攻撃者に対応するため、固定の鍵から生成される ciphertext の量を制限するために、鍵導出は session key を定期的更新できように設定できる、
- "Salting keys" は pre-computation と time-memory tradeoff attacks から保護するために使用されています。

Detailed rationale for these features can be found in Section 7.

これらの機能の詳細な理論的根拠は、 Section 7 で解説します。


## 3. SRTP フレームワーク (3. SRTP Framework)

RTP is the Real-time Transport Protocol [RFC3550]. We define SRTP as a profile of RTP. This profile is an extension to the RTP Audio/Video Profile [RFC3551]. Except where explicitly noted, all aspects of that profile apply, with the addition of the SRTP security features. Conceptually, we consider SRTP to be a "bump in the stack" implementation which resides between the RTP application and the transport layer. SRTP intercepts RTP packets and then forwards an equivalent SRTP packet on the sending side, and intercepts SRTP packets and passes an equivalent RTP packet up the stack on the receiving side.

RTP は、リアルタイムトランスポートプロトコル [RFC3550] です。私たちは、 RTP のプロファイルとして SRTP を定義します。このプロファイルは、 RTP オーディオ/ビデオプロフィール [RFC3551] の拡張です。明示的に注記がある場合を除き、そのプロファイルのすべての側面は、 SRTP セキュリティ機能を追加して適用されます。概念的に、私たちは SRTP を RTP アプリケーションとトランスポート層との間に存在する "bump in the stack" 実装であると考えています。 SRTP は RTP パケットを横取りし、等価な SRTP パケットを送信し、受信した SRTP パケットを、等価な RTP パケットにして受信側に渡します。

Secure RTCP (SRTCP) provides the same security services to RTCP as SRTP does to RTP. SRTCP message authentication is MANDATORY and thereby protects the RTCP fields to keep track of membership, provide feedback to RTP senders, or maintain packet sequence counters. SRTCP is described in Section 3.4.

SRTCP は、 SRTP が RTP に対して行うセキュリティ機能を、 RTCP に対して行います。 SRTCP のメッセージ認証は必須であり、それにより、 RTCP フィールドを保護し、メンバーシップの追跡、 RTP sender へのフィードバック、パケットのシーケンスカウンタのメンテをします。 SRTCP は 3.4 で解説します。

### 3.1 。セキュア RTP (3.1. Secure RTP)

The format of an SRTP packet is illustrated in Figure 1.

SRTP パケットのフォーマットは Figure 1 に示されています。

```
     0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<+
  |V=2|P|X|  CC   |M|     PT      |       sequence number         | |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
  |                           timestamp                           | |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
  |           synchronization source (SSRC) identifier            | |
  +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ |
  |            contributing source (CSRC) identifiers             | |
  |                               ....                            | |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
  |                   RTP extension (OPTIONAL)                    | |
+>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
| |                          payload  ...                         | |
| |                               +-------------------------------+ |
| |                               | RTP padding   | RTP pad count | |
+>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<+
| ~                     SRTP MKI (OPTIONAL)                       ~ |
| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
| :                 authentication tag (RECOMMENDED)              : |
| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
|                                                                   |
+- Encrypted Portion*                      Authenticated Portion ---+

Figure 1.  The format of an SRTP packet.  *Encrypted Portion is the same size as the plaintext for the Section 4 pre-defined transforms.
```


The "Encrypted Portion" of an SRTP packet consists of the encryption of the RTP payload (including RTP padding when present) of the equivalent RTP packet. The Encrypted Portion MAY be the exact size of the plaintext or MAY be larger. Figure 1 shows the RTP payload including any possible padding for RTP [RFC3550].

RTP パケットペイロードの暗号化部分(ある場合 RTP padding を含む)に含まれる SRTP パケットの "Encrypted Portion"。
Ecnrypted Portion のサイズは、 plaintext と同じかそれ以上。
図 1 は、 パディングを含む RTP ペイロードを表す。

None of the pre-defined encryption transforms uses any padding; for these, the RTP and SRTP payload sizes match exactly. New transforms added to SRTP (following Section 6) may require padding, and may hence produce larger payloads. RTP provides its own padding format (as seen in Fig. 1), which due to the padding indicator in the RTP header has merits in terms of compactness relative to paddings using prefix-free codes. This RTP padding SHALL be the default method for transforms requiring padding. Transforms MAY specify other padding methods, and MUST then specify the amount, format, and processing of their padding. It is important to note that encryption transforms that use padding are vulnerable to subtle attacks, especially when message authentication is not used [V02]. Each specification for a new encryption transform needs to carefully consider and describe the security implications of the padding that it uses. Message authentication codes define their own padding, so this default does not apply to authentication transforms.



None of the pre-defined encryption transforms uses any padding; for these, the RTP and SRTP payload sizes match exactly.

事前定義された暗号化 transform のいずれも、パディングを使用しません。これらのために、 RTP および SRTP ペイロードサイズが正確に一致します。

New transforms added to SRTP (following Section 6) may require padding, and may hence produce larger payloads.
SRTP に追加される新しい transform (Section 6)は、パディングを必要とするかもしれない、ひいてはより大きなペイロードを生成するかもしれない。

RTP provides its own padding format (as seen in Fig. 1), which due to the padding indicator in the RTP header has merits in terms of compactness relative to paddings using prefix-free codes.

RTP は独自のパディングフォーマット(Fig. 1)を提供し、ヘッダの Padding Indicator は、prefix free のコードで、軽量性の観点からメリットがある。

This RTP padding SHALL be the default method for transforms requiring padding.

この RTP パディングは、パディングが必要な transform のデフォルトメソッドである。

Transforms MAY specify other padding methods, and MUST then specify the amount, format, and processing of their padding.

transform は他の padding method を提供するかもしれず、その場合、サイズの判断方法と、フォーマット、処理方法を明示する。

It is important to note that encryption transforms that use padding are vulnerable to subtle attacks, especially when message authentication is not used [V02].

重要な点として、パディングを使う暗号 transform は、特にメッセージ認証を使わない場合、攻撃に弱い場合がある。

Each specification for a new encryption transform needs to carefully consider and describe the security implications of the padding that it uses.

新しい暗号変換は、パディングによるセキュリティへの影響について慎重に考える必要がある。

Message authentication codes define their own padding, so this default does not apply to authentication transforms.

メッセージ認証コードはそれ自身がパディングをもっているので、このデフォルトは認証変換には適用されない。

The OPTIONAL MKI and the RECOMMENDED authentication tag are the only fields defined by SRTP that are not in RTP. Only 8-bit alignment is assumed.

Optional MKI と、推奨される authentication tag のみが、 SRTP によって定義された RTP には無いフィールドです。 8 ビットのアライメントが想定されます。


MKI (Master Key Identifier):

configurable length, OPTIONAL.

length は設定可能で、 Optional。

The MKI is defined, signaled, and used by key management.

MKI は鍵管理によって定義、通知、使用されます。

The MKI identifies the master key from which the session key(s) were derived that authenticate and/or encrypt the particular packet.

MKI は、特定のパケットを認証/暗号化した Session Key から導出された Master Key によって識別される。

Note that the MKI SHALL NOT identify the SRTP cryptographic context, which is identified according to Section 3.2.3.

MKI は、 Section 3.2.3 に従って同定される SRTP 暗号コンテキストを識別しないものとに注意してください。

The MKI MAY be used by key management for the purposes of re-keying, identifying a particular master key within the cryptographic context (Section 3.2.1).

MKI は、 re-keying や、暗号コンテキスト(3.2.1)の特定の master key の識別のために、鍵管理によって利用されるかもしれない。



Authentication tag:

configurable length, RECOMMENDED.

length は設定可能で、 Recommended。

The authentication tag is used to carry message authentication data.

認証タグは、メッセージ認証データの伝達に使われる。

The Authenticated Portion of an SRTP packet consists of the RTP header followed by the Encrypted Portion of the SRTP packet.

SRTP パケットの認証部分は、 SRTP パケットの暗号化部分に続く RTP ヘッダから成ります。

Thus, if both encryption and authentication are applied, encryption SHALL be applied before authentication on the sender side and conversely on the receiver side.

よって、もし暗号化と認証が両方適用される場合、暗号化は、送信側では認証の前に、受信側ではその逆順に適用しなければなりません。

The authentication tag provides authentication of the RTP header and payload, and it indirectly provides replay protection by authenticating the sequence number.

認証タグは、 RTP ヘッダ及びペイロードの認証を提供し、それは間接的にシーケンス番号を認証することにより、再送保護を提供します。

Note that the MKI is not integrity protected as this does not provide any extra protection.

MKI が、保護整合性ではないことにより、追加の保護を程供養しないことに注意してください。


### 3.2 。 SRTP 暗号化コンテキスト (3.2. SRTP Cryptographic Contexts)

Each SRTP stream requires the sender and receiver to maintain cryptographic state information. This information is called the "cryptographic context".

各 SRTP ストリームは、暗号状態情報を維持するために、送信者と受信者が必要です。この情報は、「暗号コンテキスト」と呼ばれています。

SRTP uses two types of keys: session keys and master keys.

SRTP は session key と master key の 2 種類の鍵を使用しています。

By a "session key", we mean a key which is used directly in a cryptographic transform (e.g., encryption or message authentication),

session key は、 cryptographic transform (例えば、暗号化やメッセージ認証)に直接使用されるキーを意味する。

and by a "master key", we mean a random bit string (given by the key management protocol) from which session keys are derived in a cryptographically secure way.

master key は、暗号的に安全な方法で session key が導出された、(key management protocol により提供された)ランダムなビット列を意味します。

The master key(s) and other parameters in the cryptographic context are provided by key management mechanisms external to SRTP, see Section 8.

master key と暗号コンテキストにおける他のパラメータは、セクション 8 を参照して、 SRTP の外部鍵管理メカニズムによって提供されます。


#### 3.2.1. トランスフォームに依存しないパラメータ (3.2.1. Transform-independent parameters)

Transform-independent parameters are present in the cryptographic context independently of the particular encryption or authentication transforms that are used. The transform-independent parameters of the cryptographic context for SRTP consist of:

変換に依存しないパラメータが、使用される特定の暗号化または認証トランスフォームとは独立して、の暗号コンテキスト内に存在します。

The transform-independent parameters of the cryptographic context for SRTP consist of:

SRTP のための、暗号コンテキストにあるのトランスフォームに依存しないパラメータは以下で構成されています。

- a 32-bit unsigned rollover counter (ROC), which records how many times the 16-bit RTP sequence number has been reset to zero after passing through 65,535. Unlike the sequence number (SEQ), which SRTP extracts from the RTP packet header, the ROC is maintained by SRTP as described in Section 3.3.1.

- 32 ビット符号なしロールオーバカウンタ(ROC) (16 ビットの RTP シーケンス番号が 65,535 を通過した後にゼロにリセットされた回数を記録する。セクション 3.3.1 に記載のように RTP パケットヘッダから抽出される SRTP シーケンス番号 (SEQ) とは異なり、 ROC は SRTP によって維持されます。)

We define the index of the SRTP packet corresponding to a given ROC and RTP sequence number to be the 48-bit quantity

与えられた ROC と RTP シーケンス番号に対応する SRTP パケットのインデックスは 48 ビットです。

```
i = 2^16 * ROC + SEQ.
```

- for the receiver only, a 16-bit sequence number s_l, which can be thought of as the highest received RTP sequence number (see Section 3.3.1 for its handling), which SHOULD be authenticated since message authentication is RECOMMENDED,

- レシーバのみ、メッセージ認証ので、認証されるべきである最高受信した RTP シーケンス番号を(その取り扱いについては、セクション 3.3.1 を参照)が推奨されていると考えることができる 16 ビットのシーケンス番号 S_L 、

- an identifier for the encryption algorithm, i.e., the cipher and its mode of operation,

- 暗号化アルゴリズムの識別子、すなわち、暗号化とその動作モード、

- an identifier for the message authentication algorithm,

- メッセージ認証アルゴリズムの識別子、

- a replay list, maintained by the receiver only (when authentication and replay protection are provided), containing indices of recently received and authenticated SRTP packets,

- 最近受信した認証 SRTP パケットのインデックスを含む、(認証およびリプレイ保護が提供されている)レシーバによってメンテされる再生リスト、

- an MKI indicator (0/1) as to whether an MKI is present in SRTP and SRTCP packets,

- SRTP と SRTCP パケットに MKI が存在しているか否かの MKI インジケータ(0/1)

- if the MKI indicator is set to one, the length (in octets) of the MKI field, and (for the sender) the actual value of the currently active MKI (the value of the MKI indicator and length MUST be kept fixed for the lifetime of the context),

- MKI インジケータが 1 に設定されている場合、(オクテットの)長さ、そして、(センダーで) 現在アクティブな MKI(MKI インジケータと length の値は、コンテキストが維持された間は、固定でなければならない)、

- the master key(s), which MUST be random and kept secret,

- master key は、ランダムで秘密である必要がある

- for each master key, there is a counter of the number of SRTP packets that have been processed (sent) with that master key (essential for security, see Sections 3.3.1 and 9),

- 各マスターキーで、そのマスターキーを用いて(送信)処理された SRTP パケットの数のカウント(セキュリティのために不可欠 section 3.3.1 and 9)があります

- non-negative integers ne, and na, determining the length of the session keys for encryption, and message authentication.

- 非負整数 ne and na は、暗号化、およびメッセージ認証のためのセッションキーの長さを決定します。

In addition, for each master key, an SRTP stream MAY use the following associated values:

加えて、各 master key のため、 SRTP ストリームは、以下の関連する値を使用することがあります。

a master salt, to be used in the key derivation of session keys. This value, when used, MUST be random, but MAY be public. Use of master salt is strongly RECOMMENDED, see Section 9.2. A "NULL" salt is treated as 00...0.
マスター塩は、セッションキーのキー導出に使用されます。この値は、使用された場合、ランダムである必要がありますが、公共のかもしれ。マスター塩の使用が強く、セクション 9.2 を参照してください、推奨されます。「NULL」塩は 00 ... 0 として扱われます。
an integer in the set {1,2,4,...,2^24}, the "keyderivationrate", where an unspecified value is treated as zero. The constraint to be a power of 2 simplifies the session-key derivation implementation, see Section 4.3.
集合{1,2,4 、...、 2 ^ 24}内の整数で、「鍵導出不特定の値はゼロとして扱われるレート」、。 2 の累乗でする制約は、セッション鍵導出の実装を簡素化し、 4.3 節を参照してください。

- an MKI value,

&lt;From, To&gt; values, specifying the lifetime for a master key, expressed in terms of the two 48-bit index values inside whose range (including the range end-points) the master key is valid. For the use of &lt;From, To&gt;, see Section 8.1.1.  &lt;From, To&gt; is an alternative to the MKI and assumes that a master key is in one-to-one correspondence with the SRTP session key on which the &lt;From, To&gt; range is defined.
マスターキーの有効期間を指定し、値<へ、から>、マスターキーが有効で、その範囲(範囲の端点を含む)の内部に 2 48 ビットのインデックス値で表現。<へ、から>の使用については、 8.1.1 項を参照してください。<へ、から> MKI の代替であり、マスターキーが、<、乃至>範囲が定義されている SRTP セッション鍵と 1 対 1 に対応していることを前提としています。

SRTCP SHALL by default share the crypto context with SRTP, except:
SRTCP は、デフォルトでは SRTP で暗号コンテキストを共有するものとし、除きます:

no rollover counter and s_l-value need to be maintained as the RTCP index is explicitly carried in each SRTCP packet,
RTCP インデックスは明示各 SRTCP パケットで運ばれているように何ロールオーバカウンタと S_L 値は、維持される必要がありません

a separate replay list is maintained (when replay protection is provided),
別再生リストは、(再生保護が提供される場合)が維持されます

SRTCP maintains a separate counter for its master key (even if the master key is the same as that for SRTP, see below), as a means to maintain a count of the number of SRTCP packets that have been processed with that key.
SRTCP は、そのキーで処理された SRTCP パケットの数のカウントを維持するための手段として、そのマスターキー(マスターキーは、 SRTP と同じであっても、下記参照)のために別個のカウンタを維持します。

Note in particular that the master key(s) MAY be shared between SRTP and the corresponding SRTCP, if the pre-defined transforms (including the key derivation) are used but the session key(s) MUST NOT be so shared.
マスター鍵(単数または複数)(鍵導出を含む)事前定義された変換が使用される場合、 SRTP と対応 SRTCP の間で共有することができるが、セッション鍵(単数または複数)が共有されてはならないことを特に注意してください。

In addition, there can be cases (see Sections 8 and 9.1) where several SRTP streams within a given RTP session, identified by their synchronization source (SSRCs, which is part of the RTP header), share most of the crypto context parameters (including possibly master and session keys). In such cases, just as in the normal SRTP/SRTCP parameter sharing above, separate replay lists and packet counters for each stream (SSRC) MUST still be maintained. Also, separate SRTP indices MUST then be maintained.
また、など、いくつかの SRTP は、それらの同期ソース(RTP ヘッダの一部である SSRCs)により同定、与えられた RTP セッション内のストリームの場合(セクション 8 および 9.1 を参照)、共有暗号コンテキストパラメータのほとんどを(存在し得ますおそらくマスターとセッション鍵)。このような場合には、単に上記共有正常 SRTP / SRTCP パラメータと同様に、各ストリーム(SSRC)のための別個の再生リストとパケットカウンタは、依然として維持されなければなりません。また、別 SRTP インデックスは次いで、維持されなければなりません。

A summary of parameters, pre-defined transforms, and default values for the above parameters (and other SRTP parameters) can be found in Sections 5 and 8.2.
上記パラメータ(および他の SRTP パラメータ)のパラメータ、予め定義された変換、およびデフォルト値の概要はセクション 5 と 8.2 に見出すことができます。

#### 3.2.2 。変換に依存するパラメータ (3.2.2. Transform-dependent parameters)

All encryption, authentication/integrity, and key derivation parameters are defined in the transforms section (Section 4). Typical examples of such parameters are block size of ciphers, session keys, data for the Initialization Vector (IV) formation, etc. Future SRTP transform specifications MUST include a section to list the additional cryptographic context's parameters for that transform, if any.
すべての暗号化、認証/完全性、および鍵導出パラメータは、変換部分(第 4 節)で定義されています。このようなパラメータの典型的な例は、など今後の SRTP が仕様を変換暗号のブロックサイズ、セッション・キー、初期化ベクトル(IV)を形成するためのデータは、もしあれば、変換そのための追加の暗号コンテキストのパラメータをリストするセクションを含まなければならないしています。

#### 3.2.3 。暗号コンテキストにマッピングする SRTP パケット (3.2.3. Mapping SRTP Packets to Cryptographic Contexts)

Recall that an RTP session for each participant is defined [RFC3550] by a pair of destination transport addresses (one network address plus a port pair for RTP and RTCP), and that a multimedia session is defined as a collection of RTP sessions. For example, a particular multimedia session could include an audio RTP session, a video RTP session, and a text RTP session.
各参加者のための RTP セッションが宛先トランスポート・アドレスのペア(一方のネットワークアドレスと RTP と RTCP のポート対)によって、[RFC3550]を定義していることを思い出して、マルチメディアセッションは、 RTP セッションの集合として定義されています。例えば、特定のマルチメディアセッションは、オーディオ RTP セッション、ビデオ RTP セッション、およびテキスト RTP セッションを含めることができます。

A cryptographic context SHALL be uniquely identified by the triplet context identifier:
暗号コンテキストを一意三重コンテキスト識別子によって識別されなければなりません。

context id = <SSRC, destination network address, destination transport port number>
where the destination network address and the destination transport port are the ones in the SRTP packet. It is assumed that, when presented with this information, the key management returns a context with the information as described in Section 3.2.
どこ宛先ネットワークアドレスと宛先トランスポート・ポートは、 SRTP パケット内のものがあります。なお、この情報を提供するとき、セクション 3.2 で説明したように、鍵管理情報とコンテキストを返すことが想定されます。

As noted above, SRTP and SRTCP by default share the bulk of the parameters in the cryptographic context. Thus, retrieving the crypto context parameters for an SRTCP stream in practice may imply a binding to the correspondent SRTP crypto context. It is up to the implementation to assure such binding, since the RTCP port may not be directly deducible from the RTP port only. Alternatively, the key management may choose to provide separate SRTP- and SRTCP- contexts, duplicating the common parameters (such as master key(s)). The latter approach then also enables SRTP and SRTCP to use, e.g., distinct transforms, if so desired. Similar considerations arise when multiple SRTP streams, forming part of one single RTP session, share keys and other parameters.
デフォルトの共有により、 SRTP と SRTCP 暗号コンテキストのパラメータのバルク、上述したように。したがって、実際に SRTCP ストリームのための暗号コンテキストパラメータを取得すると、コレス SRTP 暗号コンテキストとの結合を意味してもよいです。 RTCP ポートのみ RTP ポートから直接推論ではないかもしれないので、それは、このような結合を保証するために、実装次第です。あるいは、鍵管理は、(例えば、マスターキー(S)のような)共通パラメータを複製し、別 SRTP-と SRTCP-コンテキストを提供するように選択することができます。後者のアプローチは、その後も、所望であれば、例えば、使用する SRTP と SRTCP を可能にする別個の変換。複数 SRTP ストリームは、単一の RTP セッション、共有キーおよびその他のパラメータの一部を形成する場合、同様の考慮事項が生じます。

If no valid context can be found for a packet corresponding to a certain context identifier, that packet MUST be discarded.
有効なコンテキストが特定のコンテキスト識別子に対応するパケットのために見つけることができない場合は、そのパケットを捨てなければなりません。

#### 3.3 。 SRTP パケット処理 (3.3. SRTP Packet Processing)

The following applies to SRTP. SRTCP is described in Section 3.4.

SRTP には以下が適用されます。 SRTCP は Section 3.4 に記述。

Assuming initialization of the cryptographic context(s) has taken place via key management, the sender SHALL do the following to construct an SRTP packet:

暗号コンテキストの初期化を、鍵管理を経由して行う場合、 Sender は SRTP パケットを構築するために、次の手順を実行しなければなりません。

Determine which cryptographic context to use as described in Section 3.2.3.

Section 3.2.3 で説明したように使用する暗号コンテキストを決定します。

Determine the index of the SRTP packet using the rollover counter, the highest sequence number in the cryptographic context, and the sequence number in the RTP packet, as described in Section 3.3.1.

Section 3.3.1 で説明したように、ロールオーバカウンタ、暗号コンテキストにおける最大シーケンス番号、 RTP パケットのシーケンス番号を使用して、 SRTP パケットのインデックスを決定します。

Determine the master key and master salt. This is done using the index determined in the previous step or the current MKI in the cryptographic context, according to Section 8.1.

master key と master salt を決定します。これは、前のステップで決定されたインデックスまたは、 Section 8.1 のように暗号コンテキストにおける現在の MKI を使用して行われます。

Determine the session keys and session salt (if they are used by the transform) as described in Section 4.3, using master key, master salt, keyderivationrate, and session key-lengths in the cryptographic context with the index, determined in Steps 2 and 3.

(transform で利用する場合) Session Key, Session Salt を決定します。導出は Section 4.3 のように、 index による暗号化コンテキストから step 2, 3 で導出された master key, master salt, key derivation rate, session key-length を使います。

Encrypt the RTP payload to produce the Encrypted Portion of the packet (see Section 4.1, for the defined ciphers). This step uses the encryption algorithm indicated in the cryptographic context, the session encryption key and the session salt (if used) found in Step 4 together with the index found in Step 2.

パケットを暗号化(section 4.1)するため、 RTP ペイロードの暗号化をする。
ここでは、暗号化コンテキストで決定された、暗号化アルゴリズムが使われる。
step 2 のインデックスと、 step 4 で決定された session key/salt が使われる。

If the MKI indicator is set to one, append the MKI to the packet.

MKI インジケータが 1 に設定されている場合は、パケットに MKI を追加します。

For message authentication, compute the authentication tag for the Authenticated Portion of the packet, as described in Section 4.2. This step uses the current rollover counter, the authentication algorithm indicated in the cryptographic context, and the session authentication key found in Step 4. Append the authentication tag to the packet.

メッセージ認証のために、 4.2 節で説明したように、パケットの認証部分についての認証タグを計算します。このステップは、現在のロールオーバカウンタ、暗号コンテキストにの認証アルゴリズム、 step 4 で見つかった session authentication key で計算し、パケットに追加します。

If necessary, update the ROC as in Section 3.3.1, using the packet index determined in Step 2.

必要であれば、ステップ 2 で決定されたパケットインデックスを使用して、セクション 3.3.1 のように ROC を更新します。

To authenticate and decrypt an SRTP packet, the receiver SHALL do the following:

パケットの認証と解読のために、 receiver は、次の手順を実行しなければなりません。

Determine which cryptographic context to use as described in Section 3.2.3.

Section 3.2.3 で説明したように、使用する暗号コンテキストを決定します。

Run the algorithm in Section 3.3.1 to get the index of the SRTP packet. The algorithm uses the rollover counter and highest sequence number in the cryptographic context with the sequence number in the SRTP packet, as described in Section 3.3.1.

SRTP パケットのインデックスを取得するには、 Section 3.3.1 におけるアルゴリズムを実行します。 Section 3.3.1 に記載されているようなアルゴリズムは、 SRTP パケットのシーケンス番号と暗号コンテキストにおけるロールオーバーカウンタとシーケンス番号の最高値を使用します。

Determine the master key and master salt. If the MKI indicator in the context is set to one, use the MKI in the SRTP packet, otherwise use the index from the previous step, according to Section 8.1.

master key & master salt を決定します。コンテキストにおける MKI インジケータが 1 に設定されている場合は、SRTP パケットに MKI を使用します、そうでない場合は、 8.1 のように前のステップからのインデックスを使用します。

Determine the session keys, and session salt (if used by the transform) as described in Section 4.3, using master key, master salt, keyderivationrate and session key-lengths in the cryptographic context with the index, determined in Steps 2 and 3.

session key & (必要なら) session salt (4.3)、暗号コンテキストの master key / master salt / keyderivationrate / session key length を index と一緒に使う。(step 2, 3).

For message authentication and replay protection, first check if the packet has been replayed (Section 3.3.2), using the Replay List and the index as determined in Step 2. If the packet is judged to be replayed, then the packet MUST be discarded, and the event SHOULD be logged.

メッセージ認証とリプレイ保護のため、最初に Step 2 で決定したリプレイリストとインデックスを用いて、パケットがリプレイされているかをチェックする(3.3.2)。
もしパケットがリプレイされたものだとわかれば、パケットは無視され、ログを残す。

Next, perform verification of the authentication tag, using the rollover counter from Step 2, the authentication algorithm indicated in the cryptographic context, and the session authentication key from Step 4. If the result is "AUTHENTICATION FAILURE" (see Section 4.2), the packet MUST be discarded from further processing and the event SHOULD be logged.
次に、ステップ 2 からロールオーバーカウンターを使用して、認証タグの検証を実行し、暗号コンテキストに示される認証アルゴリズム、及び結果が「認証失敗」である場合、ステップ 4 からセッション認証キー(セクション 4.2 を参照)、パケットは、さらなる処理から捨てなければなりませんし、イベントがログに記録されます。

Decrypt the Encrypted Portion of the packet (see Section 4.1, for the defined ciphers), using the decryption algorithm indicated in the cryptographic context, the session encryption key and salt (if used) found in Step 4 with the index from Step 2.
ステップ 2 からのインデックスと、ステップ 4 で見つかった(使用する場合)セッション暗号鍵および塩、暗号コンテキストに示される復号化アルゴリズムを使用して、(定義された暗号のために、セクション 4.1 を参照)は、パケットの暗号化部分を解読します。

Update the rollover counter and highest sequence number, s_l, in the cryptographic context as in Section 3.3.1, using the packet index estimated in Step 2. If replay protection is provided, also update the Replay List as described in Section 3.3.2.
3.3.2 項で説明したようにもリプレイリストを更新し、再生保護が提供されている場合は、ステップ 2 で推定したパケットインデックスを使用して、セクション 3.3.1 のように暗号の文脈でのロールオーバーカウンタと最高のシーケンス番号、 S_L を、更新します。

When present, remove the MKI and authentication tag fields from the packet.
存在する場合、パケットから MKI と認証タグフィールドを削除します。

### 3.3.1. パケットインデックスの決定と、 ROC / s_l の更新 (3.3.1. Packet Index Determination, and ROC, s_l Update)

SRTP implementations use an "implicit" packet index for sequencing, i.e., not all of the index is explicitly carried in the SRTP packet. For the pre-defined transforms, the index i is used in replay protection (Section 3.3.2), encryption (Section 4.1), message authentication (Section 4.2), and for the key derivation (Section 4.3).
SRTP 実装ではないすべてのインデックスのは、明示的に SRTP パケットで運ばれる、すなわち、シークエンシングのための「暗黙の」パケットインデックスを使用します。事前定義された変換のために、インデックス i は、リプレイ保護(3.3.2)、暗号化(4.1 節)、メッセージ認証(セクション 4.2)、および鍵導出(セクション 4.3)のために使用されます。

When the session starts, the sender side MUST set the rollover counter, ROC, to zero. Each time the RTP sequence number, SEQ, wraps modulo 2^16, the sender side MUST increment ROC by one, modulo 2^32 (see security aspects below). The sender's packet index is then defined as
セッションが開始すると、送信側はゼロにロールオーバーカウンター、 ROC を、設定しなければなりません。 RTP シーケンス番号、 SEQ は、モジュロ 2 ^ 16 をラップするたびに、送信側は、(以下セキュリティの側面を参照)を一度、モジュロ 2 ^ 32 で ROC を増加しなければなりません。送信者のパケットインデックスは次のように定義されています

i = 2^16 * ROC + SEQ.
Receiver-side implementations use the RTP sequence number to determine the correct index of a packet, which is the location of the packet in the sequence of all SRTP packets. A robust approach for the proper use of a rollover counter requires its handling and use to be well defined. In particular, out-of-order RTP packets with sequence numbers close to 2^16 or zero must be properly handled.
受信側の実装では、すべての SRTP パケットのシーケンスにおけるパケットの位置であり、パケットの正しいインデックスを決定するために、 RTP シーケンス番号を使用します。ロールオーバーカウンターの適切な使用のための強力なアプローチは、その取り扱いや使用が明確に定義されている必要があります。具体的には、 2 ^ 16 またはゼロに近いシーケンス番号を有するアウトオブオーダ RTP パケットが適切に処理されなければなりません。

The index estimate is based on the receiver's locally maintained ROC and sl values. At the setup of the session, the ROC MUST be set to zero. Receivers joining an on-going session MUST be given the current ROC value using out-of-band signaling such as key-management signaling. Furthermore, the receiver SHALL initialize sl to the RTP sequence number (SEQ) of the first observed SRTP packet (unless the initial value is provided by out of band signaling such as key management).
指標推定値は、受信機のローカルに保持 ROC および S に基づいて、 L 値。セッションのセットアップでは、 ROC はゼロに設定しなければなりません。上で進行中のセッションに参加する受信機は、このような鍵管理シグナリングとしてシグナリング帯域外使用して、現在の ROC 値を与えなければなりません。さらに、受信機は、 S 初期化 SHALL(初期値は、キー管理などのシグナリング帯域外で提供されていない限り)最初に観測された SRTP パケットの RTP シーケンス番号(SEQ)に L を。

On consecutive SRTP packets, the receiver SHOULD estimate the index as
連続 SRTP パケットに対して、受信機は、のようにインデックスを推定すべきです

i = 2^16 * v + SEQ,
where v is chosen from the set { ROC-1, ROC, ROC+1 } (modulo 2^32) such that i is closest (in modulo 2^48 sense) to the value 2^16 * ROC + s_l (see Appendix A for pseudocode).
V は i が値(モジュロ 2 ^ 48 の意味で)最も近くなるように、集合{ROC-1 、 ROC 、 ROC + 1}(モジュロ 2 ^ 32)から選択される 2 ^ 16 ROC は+ S_L(付録を参照*擬似コードのための A)。

After the packet has been processed and authenticated (when enabled for SRTP packets for the session), the receiver MUST use v to conditionally update its sl and ROC variables as follows. If v=(ROC-1) mod 2^32, then there is no update to sl or ROC. If v=ROC, then sl is set to SEQ if and only if SEQ is larger than the current sl; there is no change to ROC. If v=(ROC+1) mod 2^32, then s_l is set to SEQ and ROC is set to v.
(セッションの SRTP パケットの有効場合)パケットを処理し、認証された後、受信機は、条件付きでその S を更新するために V を使用しなければならない次のように L 及び ROC 変数。もし V =(ROC-1)MOD 2 ^ 32 、その後の S に更新が無い l または ROC は。 V = ROC 、次いで S の場合、 L は、配列に設定されている場合にのみ配列が S 電流よりも大きい場合、 L 。 ROC への変更はありません。 V =(ROC + 1)MOD 2 ^ 32 場合、 S_L を配列に設定され、 ROC を V に設定されています。

After a re-keying occurs (changing to a new master key), the rollover counter always maintains its sequence of values, i.e., it MUST NOT be reset to zero.
再キーイングは(新しいマスターキーへの変更)が発生し、ロールオーバーカウンタは常にその値の順序を維持した後、すなわち、それがゼロにリセットしてはなりません。

As the rollover counter is 32 bits long and the sequence number is 16 bits long, the maximum number of packets belonging to a given SRTP stream that can be secured with the same key is 2^48 using the pre- defined transforms. After that number of SRTP packets have been sent with a given (master or session) key, the sender MUST NOT send any more packets with that key. (There exists a similar limit for SRTCP, which in practice may be more restrictive, see Section 9.2.) This limitation enforces a security benefit by providing an upper bound on the amount of traffic that can pass before cryptographic keys are changed. Re-keying (see Section 8.1) MUST be triggered, before this amount of traffic, and MAY be triggered earlier, e.g., for increased security and access control to media. Recurring key derivation by means of a non-zero keyderivationrate (see Section 4.3), also gives stronger security but does not change the above absolute maximum value.
ロールオーバカウンタは 32 ビット長であり、シーケンス番号は 16 ビット長であるため、同一のキーで固定することができ、所与の SRTP ストリームに属するパケットの最大数は、事前定義された変換を使用して、 2 ^ 48 です。 SRTP パケットの数が与えられた(マスタまたはセッション)キーで送信された後、送信者はそのキーに任意のより多くのパケットを送ってはいけません。(実際にはセクション 9.2 を参照して、より限定することができる SRTCP について同様の制限が存在する。)この制限は、暗号鍵が変更される前に通過できるトラフィックの量に上限を設けることによって、セキュリティ上の利点を強制。再キーイングこのトラフィックの量の前に、トリガされなければならない(8.1 節を参照)、およびメディアへの増加、セキュリティとアクセス制御のために、例えば、先にトリガすることができます。ゼロ以外の鍵を用いて鍵の導出を定期的派生率は(4.3 節を参照)、また、強力なセキュリティを提供しますが、上記の絶対最大値を変更しません。

On the receiver side, there is a caveat to updating sl and ROC: if message authentication is not present, neither the initialization of sl, nor the ROC update can be made completely robust. The receiver's "implicit index" approach works for the pre-defined transforms as long as the reorder and loss of the packets are not too great and bit-errors do not occur in unfortunate ways. In particular, 2^15 packets would need to be lost, or a packet would need to be 2^15 packets out of sequence before synchronization is lost. Such drastic loss or reorder is likely to disrupt the RTP application itself.
受信側では、複数の更新に注意点がある l および ROC:メッセージ認証が存在しない場合、 S の初期化も L 、また ROC 更新が完全に堅牢にすることができます。受信者の「暗黙のインデックス」のアプローチは、あまりにも偉大なものではなく、ビット・エラーが不幸な方法で発生していないパケットの再注文や損失限り、事前に定義された変換のために動作します。具体的には、 2 ^ 15 のパケットが失われる必要があるだろう、またはパケットは、同期が失われる前に、シーケンスのうち、 2 ^ 15 のパケットをする必要があります。このような大幅な損失や再注文は、 RTP アプリケーション自体を破壊する可能性があります。

The algorithm for the index estimate and ROC update is a matter of implementation, and should take into consideration the environment (e.g., packet loss rate) and the cases when synchronization is likely to be lost, e.g., when the initial sequence number (randomly chosen by RTP) is not known in advance (not sent in the key management protocol) but may be near to wrap modulo 2^16.
インデックス推定値および ROC 更新のためのアルゴリズムが実装の問題であり、かつ環境に配慮しなければならない(例えば、パケット損失率)との同期が失われる可能性がある場合には、例えば、初期シーケンス番号は(ランダムに選ばれたとき、 )RTP によって事前に知られていない(鍵管理プロトコルで送信されていない)が、モジュロ 2 ^ 16 を包むように近くであってもよいです。

A more elaborate and more robust scheme than the one given above is the handling of RTP's own "rollover counter", see Appendix A.1 of [RFC3550].
上記のものよりも精巧で、より堅牢なスキームが RTP 独自の「ロールオーバーカウンタ」の取り扱いで、[RFC3550]の付録 A.1 参照してください。

## 3.3.2. リプレイ保護 (3.3.2. Replay Protection)

Secure replay protection is only possible when integrity protection is present. It is RECOMMENDED to use replay protection, both for RTP and RTCP, as integrity protection alone cannot assure security against replay attacks.
セキュア再生保護は、完全性保護が存在する場合にのみ可能です。リプレイ攻撃に対するセキュリティを確保することができないだけでは整合性の保護として、両方の RTP と RTCP のために、再生保護を使用することをお勧めします。

A packet is "replayed" when it is stored by an adversary, and then re-injected into the network. When message authentication is provided, SRTP protects against such attacks through a Replay List. Each SRTP receiver maintains a Replay List, which conceptually contains the indices of all of the packets which have been received and authenticated. In practice, the list can use a "sliding window" approach, so that a fixed amount of storage suffices for replay protection. Packet indices which lag behind the packet index in the context by more than SRTP-WINDOW-SIZE can be assumed to have been received, where SRTP-WINDOW-SIZE is a receiver-side, implementation- dependent parameter and MUST be at least 64, but which MAY be set to a higher value.
それは敵によって記憶され、その後ネットワークに再注入されるとき、パケットは、「再生」されています。メッセージ認証が提供されている場合、 SRTP はリプレイリストを通じて、このような攻撃から保護します。各 SRTP 受信機は概念的に受信され、認証されたパケットのすべてのインデックスを含む再生リストを維持します。ストレージの固定量は、再生保護のために足りるように実際には、リストは、「スライディングウィンドウ」アプローチを使用することができます。 SRTP-ウィンドウサイズは受信側、実装に依存するパラメータであり、少なくとも 64 なければならない場合 SRTP-WINDOW-SIZE を超えてコンテキストにパケットインデックス遅れパケットインデックスは、受信されたと仮定することができます。しかし、これは、より高い値に設定することができます。

The receiver checks the index of an incoming packet against the replay list and the window. Only packets with index ahead of the window, or, inside the window but not already received, SHALL be accepted.
受信機は、再生リスト及びウィンドウに対する着信パケットのインデックスをチェックします。インデックスを持つパケットだけ先に窓の、または、窓の内側が、まだ受け取っていないが、受け入れられないものとします。

After the packet has been authenticated (if necessary the window is first moved ahead), the replay list SHALL be updated with the new index.
(ウィンドウが最初に先に移動され、必要に応じて)パケットが認証された後、再生リストは、新しいインデックスを更新するものとします。

The Replay List can be efficiently implemented by using a bitmap to represent which packets have been received, as described in the Security Architecture for IP [RFC2401].
IP [RFC2401]のためのセキュリティアーキテクチャで説明したように再生リストを効率的に、受信されたパケットを表現するためにビットマップを使用して実装することができます。

## 3.4 。セキュア RTCP (3.4. Secure RTCP)

Secure RTCP follows the definition of Secure RTP. SRTCP adds three mandatory new fields (the SRTCP index, an "encrypt-flag", and the authentication tag) and one optional field (the MKI) to the RTCP packet definition. The three mandatory fields MUST be appended to an RTCP packet in order to form an equivalent SRTCP packet. The added fields follow any other profile-specific extensions.
セキュア RTCP は、 Secure RTP の定義に従います。 SRTCP は、 RTCP パケットの定義に 3 つの必須新しいフィールド(SRTCP インデックス、「暗号化フラグ」、および認証タグ)と 1 つのオプションフィールド(MKI)を追加します。 3 つの必須フィールドは、等価 SRTCP パケットを形成するために、 RTCP パケットに添付しなければなりません。追加されたフィールドは、他のプロファイル固有の拡張に従ってください。

According to Section 6.1 of [RFC3550], there is a REQUIRED packet format for compound packets. SRTCP MUST be given packets according to that requirement in the sense that the first part MUST be a sender report or a receiver report. However, the RTCP encryption prefix (a random 32-bit quantity) specified in that Section MUST NOT be used since, as is stated there, it is only applicable to the encryption method specified in [RFC3550] and is not needed by the cryptographic mechanisms used in SRTP.
[RFC3550]のセクション 6.1 によれば、化合物パケットのために必要なパケット・フォーマットがあります。 SRTCP は、最初の部分は、送信者レポートまたはレシーバレポートなければならないという点で、その要求に応じてパケットを与えられなければなりません。そこに記載されているように、それは[RFC3550]で指定された暗号化方式にのみ適用可能であり、暗号化メカニズムによって必要とされない、しかし、そのセクションで指定 RTCP 暗号プレフィックス(ランダムな 32 ビットの値)を使用してはいけません SRTP で使用されます。

```
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<+
  |V=2|P|    RC   |   PT=SR or RR   |             length          | |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
  |                         SSRC of sender                        | |
+>+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ |
| ~                          sender info                          ~ |
| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
| ~                         report block 1                        ~ |
| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
| ~                         report block 2                        ~ |
| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
| ~                              ...                              ~ |
| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
| |V=2|P|    SC   |  PT=SDES=202  |             length            | |
| +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ |
| |                          SSRC/CSRC_1                          | |
| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
| ~                           SDES items                          ~ |
| +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ |
| ~                              ...                              ~ |
+>+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ |
| |E|                         SRTCP index                         | |
| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<+
| ~                     SRTCP MKI (OPTIONAL)                      ~ |
| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
| :                     authentication tag                        : |
| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
|                                                                   |
+-- Encrypted Portion                    Authenticated Portion -----+
```


Figure 2.  An example of the format of a Secure RTCP packet, consisting of an underlying RTCP compound packet with a Sender Report and SDES packet.
The Encrypted Portion of an SRTCP packet consists of the encryption (Section 4.1) of the RTCP payload of the equivalent compound RTCP packet, from the first RTCP packet, i.e., from the ninth (9) octet to the end of the compound packet. The Authenticated Portion of an SRTCP packet consists of the entire equivalent (eventually compound) RTCP packet, the E flag, and the SRTCP index (after any encryption has been applied to the payload).
SRTCP パケットの暗号化部分は、第九(9)オクテットから化合物パケットの終わりに暗号化第一 RTCP パケットから同等の複合 RTCP パケットの RTCP ペイロードの(セクション 4.1)、即ち、で構成されています。 SRTCP パケットの認証部分が全体の当量(最終的化合物)RTCP パケット、 E フラグ、及び(任意の暗号化ペイロードに適用された後)SRTCP インデックスから成ります。

The added fields are:
追加されたフィールドは、次のとおりです。

E-flag:
E-フラグ:

1 bit, REQUIRED The E-flag indicates if the current SRTCP packet is encrypted or unencrypted. Section 9.1 of [RFC3550] allows the split of a compound RTCP packet into two lower-layer packets, one to be encrypted and one to be sent in the clear. The E bit set to "1" indicates encrypted packet, and "0" indicates non-encrypted packet.
1 ビット、現在の SRTCP パケットが暗号化または非暗号化された場合に E-フラグが必要としました。[RFC3550]のセクション 9.1 は 1 つが暗号化される、 1 つは平文で送信される二下位層パケットに複合 RTCP パケットの分割を可能にします。 E は暗号化されたパケットを示し、「0」「1」に設定ビット非暗号化されたパケットを示します。

SRTCP index:
SRTCP インデックス:

31 bits, REQUIRED The SRTCP index is a 31-bit counter for the SRTCP packet. The index is explicitly included in each packet, in contrast to the "implicit" index approach used for SRTP. The SRTCP index MUST be set to zero before the first SRTCP packet is sent, and MUST be incremented by one, modulo 2^31, after each SRTCP packet is sent. In particular, after a re-key, the SRTCP index MUST NOT be reset to zero again.
31 ビットは、 REQUIRED ザ SRTCP インデックスは SRTCP パケットの 31 ビットカウンタです。インデックスは明示的 SRTP のために使用される「暗黙の」インデックスアプローチとは対照的に、各パケットに含まれます。各 SRTCP パケットが送信された後の最初の SRTCP パケットが、モジュロ 2 ^ 31 、送信され、インクリメントされなければならない前に、 SRTCP インデックスをゼロに設定しなければなりません。特に、再キーの後、 SRTCP インデックスは再びゼロにリセットしているはずがありません。

Authentication Tag:
認証タグ:

configurable length, REQUIRED The authentication tag is used to carry message authentication data.
構成可能な長さは、必要な認証タグは、メッセージ認証データを運ぶために使用されます。

MKI:
MKI:

configurable length, OPTIONAL The MKI is the Master Key Indicator, and functions according to the MKI definition in Section 3.
設定可能な長さは、省略可能 MKI は、第 3 節で MKI 定義に従ってマスターキー指標、および機能です。

SRTCP uses the cryptographic context parameters and packet processing of SRTP by default, with the following changes:
SRTCP は、次のように変更して、デフォルトで SRTP の暗号コンテキストパラメータとパケット処理を使用しています。

The receiver does not need to "estimate" the index, as it is explicitly signaled in the packet.
それが明示的にパケットに合図されて受信機には、インデックスを「推定」する必要はありません。

Pre-defined SRTCP encryption is as specified in Section 4.1, but using the definition of the SRTCP Encrypted Portion given in this section, and using the SRTCP index as the index i. The encryption transform and related parameters SHALL by default be the same selected for the protection of the associated SRTP stream(s), while the NULL algorithm SHALL be applied to the RTCP packets not to be encrypted. SRTCP may have a different encryption transform than the one used by the corresponding SRTP. The expected use for this feature is when the former has NULL-encryption and the latter has a non NULL-encryption.
事前定義された SRTCP 暗号化は、セクション 4.1 で指定されるようであるが、このセクションに記載された SRTCP 暗号化部分の定義を使用して、インデックス i と SRTCP インデックスを使用します。暗号化変換と NULL アルゴリズムは、暗号化されていない RTCP パケットに適用されるものとしながら、関連するパラメータは、デフォルトでは、関連する SRTP ストリーム(複数可)の保護のために選択したのと同じものでなければなりません。 SRTCP は異なる暗号化は、対応する SRTP で使用されるものよりも、変換する必要があります。前者は NULL 暗号化があり、後者は非 NULL 暗号化を持っている場合、この機能のための予想される使用です。

The E-flag is assigned a value by the sender depending on whether the packet was encrypted or not.
E フラグは、パケットが暗号化されたかどうかに応じて送信者によって値が割り当てられます。

SRTCP decryption is performed as in Section 4, but only if the E flag is equal to 1. If so, the Encrypted Portion is decrypted, using the SRTCP index as the index i. In case the E-flag is 0, the payload is simply left unmodified.
SRTCP 復号はセクション 4 のように行われるが、そうである場合、 E フラグが 1 に等しい場合にのみ、暗号化された部分は、インデックス i と SRTCP インデックスを用いて、復号化されます。場合に E-flag が 0 であり、ペイロードは、単に非修飾残されます。

SRTCP replay protection is as defined in Section 3.3.2, but using the SRTCP index as the index i and a separate Replay List that is specific to SRTCP.
SRTCP リプレイ保護は、 3.3.2 項で定義されているようですが、インデックス i と SRTCP に固有の別のリプレイリストとして SRTCP インデックスを使用します。

The pre-defined SRTCP authentication tag is specified as in Section 4.2, but with the Authenticated Portion of the SRTCP packet given in this section (which includes the index). The authentication transform and related parameters (e.g., key size) SHALL by default be the same as selected for the protection of the associated SRTP stream(s).
事前定義された SRTCP 認証タグはセクション 4.2 のように指定されるが、(インデックスを含む)このセクションに記載された SRTCP パケットの認証部分と。認証には、変換および関連する SRTP ストリーム(複数可)の保護のために選択されたとして、関連するパラメータ(例えば、キーサイズ)が、デフォルトでは同じものでなければなりません。

In the last step of the processing, only the sender needs to update the value of the SRTCP index by incrementing it modulo 2^31 and for security reasons the sender MUST also check the number of SRTCP packets processed, see Section 9.2.
処理の最後のステップでは、唯一の送信者は、それはまた、セクション 9.2 を参照して、処理 SRTCP パケットの数を確認しなければならない 2 ^ 31 とセキュリティ上の理由から、送信者を法インクリメントし SRTCP インデックスの値を更新する必要があります。

Message authentication for RTCP is REQUIRED, as it is the control protocol (e.g., it has a BYE packet) for RTP.
それは RTP のための制御プロトコル(例えば、それは BYE パケットを持っている)であるとして、 RTCP のメッセージ認証は、 REQUIRED です。

Precautions must be taken so that the packet expansion in SRTCP (due to the added fields) does not cause SRTCP messages to use more than their share of RTCP bandwidth. To avoid this, the following two measures MUST be taken:
(による追加されたフィールドへの)SRTCP のパケット拡張は SRTCP メッセージが RTCP 帯域幅のシェアを超えて使用することを生じないよう十分ご注意ください。これを避けるためには、次の 2 つの対策が取られなければなりません:

When initializing the RTCP variable "avgrtcpsize" defined in chapter 6.3 of [RFC3550], it MUST include the size of the fields that will be added by SRTCP (index, E-bit, authentication tag, and when present, the MKI).
RTCP 変数「平均初期化時の RTCP [RFC3550]の章 6.3 で定義されたサイズ」は、 SRTCP(インデックス、 E ビット、認証タグ、および存在する場合、 MKI)により追加されるフィールドのサイズを含まなければなりません。

When updating the "avgrtcpsize" using the variable "packetsize" (section 6.3.3 of [RFC3550]), the value of "packetsize" MUST include the size of the additional fields added by SRTCP.
「平均更新時の RTCP 変数」パケット用いサイズ「サイズ」([RFC3550]のセクション 6.3.3)を、「パケットの値サイズ」 SRTCP によって追加された追加のフィールドのサイズを含まなければなりません。

With these measures in place the SRTCP messages will not use more than the allotted bandwidth. The effect of the size of the added fields on the SRTCP traffic will be that messages will be sent with longer packet intervals. The increase in the intervals will be directly proportional to size of the added fields. For the pre- defined transforms, the size of the added fields will be at least 14 octets, and upper bounded depending on MKI and the authentication tag sizes.
これらの対策で所定の位置に SRTCP メッセージは、割り当てられた帯域幅を超えて使用することはありません。 SRTCP トラフィックに追加されたフィールドの大きさの影響は、メッセージが長いパケット間隔で送信されることになります。間隔の増加が追加されたフィールドの大きさに正比例します。事前定義された変換のために、追加されたフィールドのサイズは、少なくとも 14 オクテットとなり、上部 MKI と認証タグのサイズに応じて境界。

## 4.事前定義された暗号化トランスフォーム (4. Pre-Defined Cryptographic Transforms)

While there are numerous encryption and message authentication algorithms that can be used in SRTP, below we define default algorithms in order to avoid the complexity of specifying the encodings for the signaling of algorithm and parameter identifiers. The defined algorithms have been chosen as they fulfill the goals listed in Section 2. Recommendations on how to extend SRTP with new transforms are given in Section 6.
私たちは、アルゴリズムやパラメータ識別子のシグナリングのためのエンコーディングを指定しての複雑さを避けるために、デフォルトのアルゴリズムを定義するの下、 SRTP で使用することができ、多数の暗号化とメッセージ認証アルゴリズムがありますが。彼らは新しい変換が第 6 節に記載されているとの SRTP を拡張する方法については、セクション 2 勧告に記載された目標を達成するように定義アルゴリズムが選択されています。

## 4.1 。暗号化 (4.1. Encryption)

The following parameters are common to both pre-defined, non-NULL, encryption transforms specified in this section.
以下のパラメータは、両方の事前に定義された、非 NULL に共通であり、暗号化は、このセクションで指定された変換します。

BLOCK_CIPHER-MODE indicates the block cipher used and its mode of operation
BLOCK_CIPHER-MODE は、ブロック使用される暗号とその動作モードを示します

nb is the bit-size of the block for the block cipher * ke is the session encryption key * ne is the bit-length of ke * ks is the session salting key * ns is the bit-length of ks * SRTPPREFIX_LENGTH is the octet length of the keystream prefix, a non-negative integer, specified by the message authentication code in use.
n 個の B は、* k 個のブロック暗号のブロックのビットサイズであり、 E は、セッション暗号鍵*は n e は k 個のビット長である K * E 鍵* n 個の塩漬けセッションは S s はのビット長であります K S * の SRTP の PREFIX_LENGTH は、使用中のメッセージ認証コードによって指定されたキーストリームプレフィックス、非負整数のオクテット長です。

The distinct session keys and salts for SRTP/SRTCP are by default derived as specified in Section 4.3.
SRTP / SRTCP のための個別のセッションキーと塩は、 4.3 節で指定されたように導出デフォルトです。

The encryption transforms defined in SRTP map the SRTP packet index and secret key into a pseudo-random keystream segment. Each keystream segment encrypts a single RTP packet. The process of encrypting a packet consists of generating the keystream segment corresponding to the packet, and then bitwise exclusive-oring that keystream segment onto the payload of the RTP packet to produce the Encrypted Portion of the SRTP packet. In case the payload size is not an integer multiple of n_b bits, the excess (least significant) bits of the keystream are simply discarded. Decryption is done the same way, but swapping the roles of the plaintext and ciphertext.
暗号化は SRTP マップで SRTP パケットインデックスと擬似ランダムキーストリームセグメントへの秘密鍵を定義して変換します。各キーストリームセグメントは、単一の RTP パケットを暗号化します。パケットを暗号化するプロセスは、パケットに対応するキーストリーム・セグメントを生成から成り、その後 SRTP パケットの暗号化部分を生成する RTP パケットのペイロードにセグメント鍵ストリーム排他的論理和をビット単位。場合にペイロードサイズが N_B ビットの整数倍ではない、キーストリームの過剰(最下位)ビットは単に破棄されます。復号化は同じように行われますが、平文と暗号文の役割を交換しています。

```
+----+   +------------------+---------------------------------+
| KG |-->| Keystream Prefix |          Keystream Suffix       |---+
+----+   +------------------+---------------------------------+   |
                                                                  |
                            +---------------------------------+   v
                            |     Payload of RTP Packet       |->(*)
                            +---------------------------------+   |
                                                                  |
                            +---------------------------------+   |
                            | Encrypted Portion of SRTP Packet|<--+
                            +---------------------------------+
Figure 3: Default SRTP Encryption Processing. Here KG denotes the keystream generator, and (*) denotes bitwise exclusive-or.
```

図 3:デフォルトの SRTP の暗号化処理。ここで KG は、キーストリームジェネレータであり、(*)ビットごとの排他的論理和を表します。

The definition of how the keystream is generated, given the index, depends on the cipher and its mode of operation. Below, two such keystream generators are defined. The NULL cipher is also defined, to be used when encryption of RTP is not required.
キーストリームは、インデックス与え、どのように生成されるかの定義は、暗号化とその動作モードに依存します。以下は、二つのそのようなキーストリームジェネレータが定義されています。 NULL 暗号は、 RTP の暗号化が必要とされていないときに使用されるように、定義されています。

The SRTP definition of the keystream is illustrated in Figure 3. The initial octets of each keystream segment MAY be reserved for use in a message authentication code, in which case the keystream used for encryption starts immediately after the last reserved octet. The initial reserved octets are called the "keystream prefix" (not to be confused with the "encryption prefix" of [RFC3550, Section 6.1]), and the remaining octets are called the "keystream suffix". The keystream prefix MUST NOT be used for encryption. The process is illustrated in Figure 3.
キーストリームの SRTP 定義は、各キーストリームセグメントの最初のオクテットは、暗号化に用いる鍵ストリームが最後の予約オクテットの直後に開始する場合には、メッセージ認証コード、における使用のために予約することができる。図 3 に示されています。初期の予約オクテットは([RFC3550 、セクション 6.1]の「暗号化プレフィックス」と混同しない)「キーストリーム接頭辞」と呼ばれ、残りのオクテットは、「キーストリームサフィックス」と呼ばれています。キーストリームのプレフィックスは、暗号化に使用してはいけません。プロセスは、図 3 に示されています。

The number of octets in the keystream prefix is denoted as SRTPPREFIXLENGTH. The keystream prefix is indicated by a positive, non-zero value of SRTPPREFIXLENGTH. This means that, even if confidentiality is not to be provided, the keystream generator output may still need to be computed for packet authentication, in which case the default keystream generator (mode) SHALL be used.
キーストリーム接頭辞のオクテットの数は、 SRTP 用として示され PREFIX の LENGTH 。キーストリーム接頭辞は SRTP 用の正の非ゼロ値によって示される PREFIX の LENGTH 。これは、機密性を提供するようにされていない場合でも、キーストリーム発生器の出力はまだデフォルトのキーストリーム発生器(モード)を使用しなければならない、その場合、パケットの認証のために計算する必要があるかもしれない、ということを意味します。

The default cipher is the Advanced Encryption Standard (AES) [AES], and we define two modes of running AES, (1) Segmented Integer Counter Mode AES and (2) AES in f8-mode. In the remainder of this section, let E(k,x) be AES applied to key k and input block x.
デフォルト暗号は[AES]の Advanced Encryption Standard(AES)であり、そして我々は、 F8-モードで AES を実行して 2 つのモード、(1)セグメント化された整数カウンタモードの AES 及び(2)AES を定義します。このセクションの残りでは、 E(K 、 X)とする AES 鍵 K と入力ブロック x に適用すること。

## 4.1.1 。カウンタモードで AES (4.1.1. AES in Counter Mode)

Conceptually, counter mode [AES-CTR] consists of encrypting successive integers. The actual definition is somewhat more complicated, in order to randomize the starting point of the integer sequence. Each packet is encrypted with a distinct keystream segment, which SHALL be computed as follows.

概念的には、カウンタモード[AES-CTR]は連続した整数を暗号化することから成ります。実際の定義は、整数シーケンスの開始点をランダム化するため、やや複雑です。各パケットは、次のように計算される異なるキーストリームセグメントで暗号化されています。

A keystream segment SHALL be the concatenation of the 128-bit output blocks of the AES cipher in the encrypt direction, using key k = k_e, in which the block indices are in increasing order. Symbolically, each keystream segment looks like

キーストリームセグメントは、 AES 暗号の 128 ビット出力ブロックの暗号化方向の連結でなければなりません。
キーは `k=k_e` を利用し、ブロックインデックッスは昇順に並べられる。

各キーストリームセグメントは次のようになります

```
E(k, IV) || E(k, IV + 1 mod 2^128) || E(k, IV + 2 mod 2^128) ...
```

where the 128-bit integer value IV SHALL be defined by the SSRC, the SRTP packet index i, and the SRTP session salting key k_s, as below.

128 ビットの整数値 IV は、 SSRC, SRTP packet index i 、および SRTP Session salt key K_s によって以下のように定義されます。


```
IV = (k_s * 2^16) XOR (SSRC * 2^64) XOR (i * 2^16)
```

Each of the three terms in the XOR-sum above is padded with as many leading zeros as needed to make the operation well-defined, considered as a 128-bit value.
操作は、よく定義するために、必要に応じて上記 XOR 和に 3 つの項の各々は、 128 ビットの値として考え、などの多くの先行ゼロが埋め込まれています。

The inclusion of the SSRC allows the use of the same key to protect distinct SRTP streams within the same RTP session, see the security caveats in Section 9.1.
SSRC の包含は、同じ RTP セッション内で個別の SRTP ストリームを保護するセクション 9.1 のセキュリティ警告を参照するには、同じキーを使用することができます。

In the case of SRTCP, the SSRC of the first header of the compound packet MUST be used, i SHALL be the 31-bit SRTCP index and ke, ks SHALL be replaced by the SRTCP encryption session key and salt.
SRTCP の場合には、化合物パケットの最初のヘッダの SSRC を使用しなければならない、私は 31 ビットの SRTCP インデックスと K でなければならない K 、 E s は SRTCP 暗号化セッション鍵と塩で置き換えること SHALL 。

Note that the initial value, IV, is fixed for each packet and is formed by "reserving" 16 zeros in the least significant bits for the purpose of the counter. The number of blocks of keystream generated for any fixed value of IV MUST NOT exceed 2^16 to avoid keystream re-use, see below. The AES has a block size of 128 bits, so 2^16 output blocks are sufficient to generate the 2^23 bits of keystream needed to encrypt the largest possible RTP packet (except for IPv6 "jumbograms" [RFC2675], which are not likely to be used for RTP-based multimedia traffic). This restriction on the maximum bit-size of the packet that can be encrypted ensures the security of the encryption method by limiting the effectiveness of probabilistic attacks [BDJR].
初期値 IV は、パケット毎に固定され、カウンタの目的のために最下位ビットに「予約」 16 ゼロが形成されています。キーストリームのブロックの数は、鍵ストリームの再使用を避けるために 2 ^ 16 を超えてはならない IV のいずれかの固定値のために生成、以下を参照されたいです。 AES は、 SO 2 ^ 16 個の出力ブロックは、キーストリームの 2 ^ 23 ビットを生成するのに十分である IPv6 の「ジャンボグラム」を除いて(最大可能 RTP パケットを暗号化するのに必要な、そうでない[RFC2675]を、 128 ビットのブロックサイズを有します RTP ベースのマルチメディアトラフィックのために使用されます)。暗号化できるパケットの最大ビットサイズのこの制限は、確率的な攻撃[BDJR]の有効性を制限することにより、暗号化方式のセキュリティを確保します。

For a particular Counter Mode key, each IV value used as an input MUST be distinct, in order to avoid the security exposure of a two- time pad situation (Section 9.1). To satisfy this constraint, an implementation MUST ensure that the combination of the SRTP packet index of ROC || SEQ, and the SSRC used in the construction of the IV are distinct for any particular key. The failure to ensure this uniqueness could be catastrophic for Secure RTP. This is in contrast to the situation for RTP itself, which may be able to tolerate such failures. It is RECOMMENDED that, if a dedicated security module is present, the RTP sequence numbers and SSRC either be generated or checked by that module (i.e., sequence-number and SSRC processing in an SRTP system needs to be protected as well as the key).
特定のカウンタモードキーの入力として使用される各 IV 値は、 2 時間パッド状況(セクション 9.1)のセキュリティリスクを回避するために、明確でなければなりません。この制約を満たすために、実装は、 ROC の SRTP パケットインデックスの組み合わせ確実にしなければなりません|| IV の構築に使用される配列、及び SSRC は、任意の特定のキーのために異なっています。この一意性を確保するために失敗は、 Secure RTP のために壊滅的である可能性があります。これは、障害を許容することができるかもしれ RTP 自体の状況とは対照的です。専用のセキュリティモジュールが存在する場合、 RTP シーケンス番号及び SSRC は、いずれかの発生やそのモジュールによってチェックされることが推奨される(すなわち、 SRTP システムにおけるシーケンス番号と SSRC 処理は、キーと同様に保護する必要があります) 。

## 4.1.2 。 F8-モードの AES (4.1.2. AES in f8-mode)

To encrypt UMTS (Universal Mobile Telecommunications System, as 3G networks) data, a solution (see [f8-a] [f8-b]) known as the f8- algorithm has been developed. On a high level, the proposed scheme is a variant of Output Feedback Mode (OFB) [HAC], with a more elaborate initialization and feedback function. As in normal OFB, the core consists of a block cipher. We also define here the use of AES as a block cipher to be used in what we shall call "f8-mode of operation" RTP encryption. The AES f8-mode SHALL use the same default sizes for session key and salt as AES counter mode.
UMTS(ユニバーサル・モバイル・テレコミュニケーション・システム、 3G ネットワ​​ークのような)データを暗号化するために、[8-アルゴリズムとして知られている解決策は、(参照[F8-A] [F8-B])が開発されています。高いレベルでは、提案方式は、より精巧な初期化とフィードバック機能を備えた出力フィードバックモード(OFB)[HAC]の変異体です。正常 OFB のように、コアは、ブロック暗号で構成されています。また、ここでは、 RTP 暗号化「操作の F8-モードを」呼ぶ何に使用するブロック暗号として AES を使用することを定義します。 AES の F8-mode は AES カウンタモードとしてセッションキーと塩のために同じデフォルトのサイズを使用しなければなりません。

Figure 4 shows the structure of block cipher, E, running in f8-mode.
図 4 は、 F8-モードで実行して、ブロック暗号、 E の構造を示します。

```
                IV
                |
                v
            +------+
            |      |
       +--->|  E   |
       |    +------+
       |        |
 m -> (*)       +-----------+-------------+--  ...     ------+
       |    IV' |           |             |                  |
       |        |   j=1 -> (*)    j=2 -> (*)   ...  j=L-1 ->(*)
       |        |           |             |                  |
       |        |      +-> (*)       +-> (*)   ...      +-> (*)
       |        |      |    |        |    |             |    |
       |        v      |    v        |    v             |    v
       |    +------+   | +------+    | +------+         | +------+
k_e ---+--->|  E   |   | |  E   |    | |  E   |         | |  E   |
            |      |   | |      |    | |      |         | |      |
            +------+   | +------+    | +------+         | +------+
                |      |    |        |    |             |    |
                +------+    +--------+    +--  ...  ----+    |
                |           |             |                  |
                v           v             v                  v
               S(0)        S(1)          S(2)  . . .       S(L-1)

Figure 4.  f8-mode of operation (asterisk, (*), denotes bitwise XOR). The figure represents the KG in Figure 3, when AES-f8 is used.
```

## 4.1.2.1 。 F8 キーストリームの生成 (4.1.2.1. f8 Keystream Generation)

The Initialization Vector (IV) SHALL be determined as described in Section 4.1.2.2 (and in Section 4.1.2.3 for SRTCP).
セクション 4.1.2.2 に記載されるように初期化ベクトル(IV)を決定しなければならない(と SRTCP については、セクション 4.1.2.3 で)。

Let IV', S(j), and m denote nb-bit blocks. The keystream, S(0) ||... || S(L-1), for an N-bit message SHALL be defined by setting IV' = E(ke XOR m, IV), and S(-1) = 00..0. For j = 0,1,..,L-1 where L = N/n_b (rounded up to nearest integer if it is not already an integer) compute
IV」、 S(J)、および m 表す n を聞かせて B ビットのブロック。キーストリーム、 S(0)|| ... || N ビットのメッセージのための S(L-1)は、 IV」= E(K 設定することによって定義されるものの E XOR m を、 IV)、および S(-1)= 00..0 を。 j に対する= 0,1 、...、 L-1 、 L = N / N_B(それが既に整数でない場合、最も近い整数に切り上げ)計算

S(j) = E(k_e, IV' XOR j XOR S(j-1))
Notice that the IV is not used directly. Instead it is fed through E under another key to produce an internal, "masked" value (denoted IV') to prevent an attacker from gaining known input/output pairs.
IV は直接使用されていないことに注意してください。その代わりに、既知の入力/出力ペアを獲得する攻撃を防ぐために内部、「マスク」の値(示さ IV ')を生成するために別のキーの下に E を介して供給されます。

The role of the internal counter, j, is to prevent short keystream cycles. The value of the key mask m SHALL be
内部カウンタの役割、 j は、短いキーストリームのサイクルを防ぐためです。キーマスク M の値でなければなりません

m = k_s || 0x555..5,
i.e., the session salting key, appended by the binary pattern 0101.. to fill out the entire desired key size, n_e.
すなわち、バイナリパターン 0101 が付加キーを、塩漬けセッションが.. n_e を全体の目的のキーのサイズを記入します。

The sender SHOULD NOT generate more than 2^32 blocks, which is sufficient to generate 2^39 bits of keystream. Unlike counter mode, there is no absolute threshold above (below) which f8 is guaranteed to be insecure (secure). The above bound has been chosen to limit, with sufficient security margin, the probability of degenerative behavior in the f8 keystream generation.
送信者は、キーストリームの 2 ^ 39 ビットを生成するのに十分である以上 2 ^ 32 ブロックを生成するべきではありません。カウンタモードとは異なり、(固定)F8 が安全でないことが保証されている(以下)は、上記絶対的な閾値は存在しません。バインドされた上記の十分なセキュリティマージン、 F8 キーストリーム生成における変性行動の確率で、制限するように選択されています。

## 4.1.2.2 。 F8 SRTP IV の形成 (4.1.2.2. f8 SRTP IV Formation)

The purpose of the following IV formation is to provide a feature which we call implicit header authentication (IHA), see Section 9.5.
次 IV 形成の目的は、 9.5 項を参照してください、我々は暗黙のヘッダ認証(IHA)を呼び出す機能を提供することです。

The SRTP IV for 128-bit block AES-f8 SHALL be formed in the following way:
128 ビットブロック AES-F8 のための SRTP IV は以下のように形成されなければなりません。

IV = 0x00 || M || PT || SEQ || TS || SSRC || ROC
M, PT, SEQ, TS, SSRC SHALL be taken from the RTP header; ROC is from the cryptographic context.
M 、 PT 、 SEQ 、 TS 、 SSRC は、 RTP ヘッダから取らなければなりません。 ROC は、暗号コンテキストからです。

The presence of the SSRC as part of the IV allows AES-f8 to be used when a master key is shared between multiple streams within the same RTP session, see Section 9.1.
IV の一部として SSRC の存在は、マスターキーは、セクション 9.1 を参照して、同じ RTP セッション内で複数のストリーム間で共有される場合に AES-F8 を使用することを可能にします。

## 4.1.2.3 。 F8 SRTCP IV の形成 (4.1.2.3. f8 SRTCP IV Formation)

The SRTCP IV for 128-bit block AES-f8 SHALL be formed in the following way:
128 ビットブロック AES-F8 用 SRTCP IV は以下のように形成されなければなりません。

IV= 0..0 || E || SRTCP index || V || P || RC || PT || length || SSRC
where V, P, RC, PT, length, SSRC SHALL be taken from the first header in the RTCP compound packet. E and SRTCP index are the 1-bit and 31-bit fields added to the packet.
V 、 P 、 RC 、 PT 、長さ、 SSRC は RTCP 化合物パケットの最初のヘッダから講じなければなりません。 E および SRTCP インデックス 1 ビットと 31 ビットのフィールドは、パケットに付加されています。

## 4.1.3 。 NULL 暗号 (4.1.3. NULL Cipher)

The NULL cipher is used when no confidentiality for RTP/RTCP is requested. The keystream can be thought of as "000..0", i.e., the encryption SHALL simply copy the plaintext input into the ciphertext output.
RTP / RTCP には機密性が要求されていない場合、 NULL 暗号が使用されています。キーストリームはつまり、暗号化は、単に暗号文出力にプレーンテキスト入力をコピーするものとし、「000..0」と考えることができます。

## 4.2 。メッセージ認証と整合性 (4.2. Message Authentication and Integrity)

Throughout this section, M will denote data to be integrity protected. In the case of SRTP, M SHALL consist of the Authenticated Portion of the packet (as specified in Figure 1) concatenated with the ROC, M = Authenticated Portion || ROC; in the case of SRTCP, M SHALL consist of the Authenticated Portion (as specified in Figure 2) only.
このセクション全体で、 M はデータを示してますが完全性が保護されます。 SRTP の場合、 M は、 ROC 、 M =認証部分と連結し(図 1 で指定されるように)パケットの認証部の構成されなければならない|| ROC; のみ(図 2 で指定されるように)SRTCP の場合には、 M は、認証部の構成されなければなりません。

Common parameters:
一般的なパラメータ:

AUTH_ALG is the authentication algorithm
AUTH_ALG は、認証アルゴリズムであります

k_a is the session message authentication key
k_a は、セッションメッセージ認証キーです

n_a is the bit-length of the authentication key
N_A は、認証キーのビット長であります

n_tag is the bit-length of the output authentication tag
n_tag 出力認証タグのビット長であります

SRTPPREFIXLENGTH is the octet length of the keystream prefix as defined above, a parameter of AUTH_ALG
SRTP の PREFIX の上記に定義した長さが AUTH_ALG のパラメータキーストリームプレフィックスのオクテット長であります

The distinct session authentication keys for SRTP/SRTCP are by default derived as specified in Section 4.3.
SRTP / SRTCP のための個別のセッション認証キーは、セクション 4.3 で指定されたように導出デフォルトです。

The values of na, ntag, and SRTPPREFIXLENGTH MUST be fixed for any particular fixed value of the key.
n 個の値 A 、 N タグ、および SRTP の PREFIX の LENGTH は、キーのいずれかの特定の固定値のために固定されなければなりません。

We describe the process of computing authentication tags as follows. The sender computes the tag of M and appends it to the packet. The SRTP receiver verifies a message/authentication tag pair by computing a new authentication tag over M using the selected algorithm and key, and then compares it to the tag associated with the received message. If the two tags are equal, then the message/tag pair is valid; otherwise, it is invalid and the error audit message "AUTHENTICATION FAILURE" MUST be returned.
私たちは、次のように認証タグを計算する処理を記述します。送信者は、 M のタグを計算し、パケットに追加します。 SRTP 受信機は、選択されたアルゴリズムと鍵を使用して、 M 上に新しい認証タグを計算することによって、メッセージ/認証タグのペアを検証し、受信したメッセージに関連付けられたタグと比較します。二つのタグが等しい場合、メッセージ/タグのペアが有効です。それ以外の場合は無効であり、エラー監査メッセージ「認証失敗」が返されなければなりません。

## 4.2.1 。 HMAC-SHA1 (4.2.1. HMAC-SHA1)

The pre-defined authentication transform for SRTP is HMAC-SHA1 [RFC2104]. With HMAC-SHA1, the SRTPPREFIXLENGTH (Figure 3) SHALL be 0. For SRTP (respectively SRTCP), the HMAC SHALL be applied to the session authentication key and M as specified above, i.e., HMAC(ka, M). The HMAC output SHALL then be truncated to the ntag left-most bits.
事前定義された認証 SRTP 用に変換は、 HMAC-SHA1 [RFC2104]です。 HMAC-SHA1 、 SRTP のと PREFIX の LENGTH(図 3)は、 SRTP に関して 0(それぞれ SRTCP)でなければならない、 HMAC は、上記指定された、すなわち、 HMAC(K のようなセッション認証キーおよび M に適用されるものと、 A 、 M)。 HMAC の出力は、 n 個に切り捨てなければならないタグ左端ビット。

## 4.3 。鍵の導出 (4.3. Key Derivation)

## 4.3.1 。キー導出アルゴリズム (4.3.1. Key Derivation Algorithm)

Regardless of the encryption or message authentication transform that is employed (it may be an SRTP pre-defined transform or newly introduced according to Section 6), interoperable SRTP implementations MUST use the SRTP key derivation to generate session keys. Once the key derivation rate is properly signaled at the start of the session, there is no need for extra communication between the parties that use SRTP key derivation.
かかわらず、暗号化やメッセージ認証のものが採用されている変換(それが変換または新た項 6 に記載の導入 SRTP の事前定義されてもよい)、相互運用可能な SRTP 実装は、セッション鍵を生成するために、 SRTP 鍵導出を使用しなければなりません。鍵導出率が適切にセッションの開始時に通知されると、 SRTP 鍵導出を使用し、当事者間の余分な通信のための必要はありません。

```
          packet index ---+
                          |
                          v
+-----------+ master  +--------+ session encr_key
| ext       | key     |        |---------->
| key mgmt  |-------->|  key   | session auth_key
| (optional |         | deriv  |---------->
| rekey)    |-------->|        | session salt_key
|           | master  |        |---------->
+-----------+ salt    +--------+

Figure 5: SRTP key derivation.
```

At least one initial key derivation SHALL be performed by SRTP, i.e., the first key derivation is REQUIRED. Further applications of the key derivation MAY be performed, according to the "keyderivationrate" value in the cryptographic context. The key derivation function SHALL initially be invoked before the first packet and then, when r > 0, a key derivation is performed whenever index mod r equals zero. This can be thought of as "refreshing" the session keys. The value of "keyderivationrate" MUST be kept fixed for the lifetime of the associated master key.
少なくとも一つの初期鍵導出が SRTP 者が行わなければならない、すなわち、第一の鍵導出が必要となります。鍵導出のさらなる用途は、「キーに従って、実行することができる派生暗号コンテキストにおけるレート」の値。鍵導出関数は、最初に、最初のパケットの前に起動されるものとし、その後、 R> 0 は、鍵導出が行われた場合、インデックスの mod r がゼロに等しいときはいつでも。これは、セッションキーを「リフレッシュ」と考えることができます。「キーの値導出率」は関連するマスターキーの寿命のために固定保持されなければなりません。

Interoperable SRTP implementations MAY also derive session salting keys for encryption transforms, as is done in both of the pre- defined transforms.
事前定義された変換の両方で行われるように相互運用可能な SRTP 実装はまた、暗号化変換のためのセッション塩析鍵を導出することができます。

Let m and n be positive integers. A pseudo-random function family is a set of keyed functions {PRFn(k,x)} such that for the (secret) random key k, given m-bit x, PRFn(k,x) is an n-bit string, computationally indistinguishable from random n-bit strings, see [HAC]. For the purpose of key derivation in SRTP, a secure PRF with m = 128 (or more) MUST be used, and a default PRF transform is defined in Section 4.3.3.
M しようと n は正の整数で。擬似ランダム関数のファミリーは、キー付き関数{PRF の集合である(秘密)ランダム鍵 K 、所与の m ビットの X 、 PRF のためのような N(K 、 X)} N(K x)は n ビットでありますランダムな n ビット列から計算区別できない文字列は、[HAC]参照します。 SRTP における鍵導出のために、 M = 128(またはそれ以上)とのセキュアな PRF を使用しなければなりません、そしてデフォルト PRF 変換セクション 4.3.3 で定義されています。

Let "a DIV t" denote integer division of a by t, rounded down, and with the convention that "a DIV 0 = 0" for all a. We also make the convention of treating "a DIV t" as a bit string of the same length as a, and thus "a DIV t" will in general have leading zeros.
「DIV t は」 t での整数除算を表すもの、およびすべてのための「DIV 0 = 0」が慣例で切り捨て。また、同じ長さのビット列として「DIV t を」治療する規則を作り、ひいては「DIV t は、」一般的にはゼロをリードしています。

Key derivation SHALL be defined as follows in terms of <label>, an 8-bit constant (see below), mastersalt and keyderivation_rate, as determined in the cryptographic context, and index, the packet index (i.e., the 48-bit ROC || SEQ for SRTP):
鍵導出が<ラベル>の観点から、以下のように、 8 ビットの定数(下記参照)マスター defined さ SHALL 塩および key 暗号コンテキストにおいて決定されるように、 derivation_rate を、インデックス、パケットインデックス(すなわち、 48 ビット SRTP のための ROC || SEQ):

Let r = index DIV keyderivationrate (with DIV as defined above).
R =インデックス DIV キーましょう導出(上記で定義した通りで DIV)レート。

Let key_id = <label> || r.
みましょうの key_id = <ラベル> || R 。

Let x = keyid XOR mastersalt, where keyid and mastersalt are aligned so that their least significant bits agree (right-alignment).
X =キーましょう ID の XOR マスターキー塩、 ID とマスター塩は、それらの最下位ビット(右アライメント)一致するように整列されています。

<label> MUST be unique for each type of key to be derived. We currently define <label> 0x00 to 0x05 (see below), and future extensions MAY specify new values in the range 0x06 to 0xff for other purposes. The n-bit SRTP key (or salt) for this packet SHALL then be derived from the master key, k_master as follows:
<ラベル>は導出されるキーの種類ごとにユニークでなければなりません。我々は現在、定義の<label>は 0x00(下記参照)、 0x05 のにし、将来の拡張は、他の目的のために 0xff の範囲 0x06 のに新しい値を指定するかもしれません。このパケットの n ビット SRTP 鍵(またはその塩)を、 k_master 次のように、マスター鍵から導出されなければなりません。

PRF_n(k_master, x).
(The PRF may internally specify additional formatting and padding of x, see e.g., Section 4.3.3 for the default PRF.)
(PRF は内部で、デフォルト PRF のために、例えば、セクション 4.3.3 を参照してください追加の書式と x のパディングを指定することもできます。)

The session keys and salt SHALL now be derived using:
セッションキーと塩は現在使用して誘導されなければなりません。

ke (SRTP encryption): <label> = 0x00, n = ne.
k 個の電子(SRTP 暗号化):<ラベル> = 0x00 で、 N = N E 。

ka (SRTP message authentication): <label> = 0x01, n = na.
k は<ラベル> = 0x01 で、 N = N:(SRTP メッセージ認証)。

ks (SRTP salting key): <label> = 0x02, n = ns.
K S(SRTP の塩析キー):<ラベル> = 0x02 の、 N = N S 。

where ne, ns, and n_a are from the cryptographic context.
ここで、 n は、 E 、 N 、 S 、及び N_A は、暗号コンテキストからです。

The master key and master salt MUST be random, but the master salt MAY be public.
マスターキーとマスター塩はランダムである必要がありますが、マスター塩は、公開してもよい(MAY)。

Note that for a keyderivationrate of 0, the application of the key derivation SHALL take place exactly once.
キーのこと Note 導出 0 の割合、鍵導出のアプリケーションが正確に一度行わとらなければなりません。

The definition of DIV above is purely for notational convenience. For a non-zero t among the set of allowed key derivation rates, "a DIV t" can be implemented as a right-shift by the base-2 logarithm of t. The derivation operation is further facilitated if the rates are chosen to be powers of 256, but that granularity was considered too coarse to be a requirement of this specification.
DIV の定義は、上記の表記の便宜上のために、純粋です。許可鍵導出レートのセットの中の非ゼロ t について、「DIV t は」 T の 2 を底とする対数だけ右シフトとして実施することができます。レートが 256 の累乗になるように選択された場合に派生動作がさらに容易になるが、その粒度は、本明細書の要件であることが粗すぎると考えられました。

The upper limit on the number of packets that can be secured using the same master key (see Section 9.2) is independent of the key derivation.
同じマスターキーを使用して固定することができるパケットの数の上限は(セクション 9.2 を参照)鍵導出とは無関係です。

## 4.3.2 。 SRTCP 鍵の導出 (4.3.2. SRTCP Key Derivation)

SRTCP SHALL by default use the same master key (and master salt) as SRTP. To do this securely, the following changes SHALL be done to the definitions in Section 4.3.1 when applying session key derivation for SRTCP.
SRTCP は、デフォルトでは SRTP と同じマスターキー(マスター塩)を使用しなければなりません。 SRTCP のためのセッションキー導出を適用するときに安全にこれを行うには、次のような変更は、 4.3.1 項の定義に行われるものとします。

Replace the SRTP index by the 32-bit quantity: 0 || SRTCP index (i.e., excluding the E-bit, replacing it with a fixed 0-bit), and use <label> = 0x03 for the SRTCP encryption key, <label> = 0x04 for the SRTCP authentication key, and, <label> = 0x05 for the SRTCP salting key.
32 ビットの値によって SRTP インデックスを置き換える:0 || SRTCP 暗号化キーの SRTCP インデックス(すなわち、固定された 0 ビットでそれを置き換える、 E ビットを除く)、および使用の<label> = 0x03 の、 SRTCP 認証キーの<ラベル> = 0x04 の、そして、<ラベル> =キーを塩漬け SRTCP のための 0x05 を。

## 4.3.3 。 AES-CM PRF (4.3.3. AES-CM PRF)

The currently defined PRF, keyed by 128, 192, or 256 bit master key, has input block size m = 128 and can produce n-bit outputs for n up to 2^23. PRFn(kmaster,x) SHALL be AES in Counter Mode as described in Section 4.1.1, applied to key k_master, and IV equal to (x*2^16), and with the output keystream truncated to the n first (left-most) bits. (Requiring n/128, rounded up, applications of AES.)
現在 128 をキー PRF 、 192 、または 256 ビットのマスターキーを定義して、入力ブロックサイズ m = 128 を有しており、 2 ^ 23 までの n に対して n ビット出力を生成することができます。 PRF N(k 個のマスター、 X)セクション 4.1.1 に記載したように、カウンタモードで AES ことキー k_master に適用し、そして(X * 2 ^ 16)に IV が等しく、出力キーストリームは、(最初の n 個に切り捨てと SHALL 一番左の)ビット。(N / 128 を必要とする、 AES のアプリケーションを切り上げ。)

## 5.デフォルトおよび実装に必須のトランスフォーム (5. Default and mandatory-to-implement Transforms)

The default transforms also are mandatory-to-implement transforms in SRTP. Of course, "mandatory-to-implement" does not imply "mandatory-to-use". Table 1 summarizes the pre-defined transforms. The default values below are valid for the pre-defined transforms.
デフォルトの変換はまた、実装に必須の SRTP で変換をしています。もちろん、「実装に必須の」は「必須に使える」を意味するものではありません。表 1 は、あらかじめ定義された変換を要約します。以下のデフォルト値は、事前定義された変換のために有効です。

```
                      mandatory-to-impl.   optional     default

encryption            AES-CM, NULL         AES-f8       AES-CM
message integrity     HMAC-SHA1              -          HMAC-SHA1
key derivation (PRF)  AES-CM                 -          AES-CM
```

Table 1: Mandatory-to-implement, optional and default transforms in SRTP and SRTCP.

## 5.1 。暗号化:AES-CM と NULL (5.1. Encryption: AES-CM and NULL)

AES running in Segmented Integer Counter Mode, as defined in Section 4.1.1, SHALL be the default encryption algorithm. The default key lengths SHALL be 128-bit for the session encryption key (ne). The default session salt key-length (ns) SHALL be 112 bits.
セグメント化された整数カウンタモードで実行されている AES は、 4.1.1 項で定義されるように、デフォルトの暗号化アルゴリズムされなければなりません。デフォルトのキーの長さは、セッション暗号鍵(n は 128 ビットでなければならない E)。デフォルトセッション塩鍵長(n 個の S)が 112 ビットでなければなりません。

The NULL cipher SHALL also be mandatory-to-implement.
NULL 暗号はまた、実装に必須のものでなければなりません。

## 5.2 。メッセージ認証/完全性:HMAC-SHA1 (5.2. Message Authentication/Integrity: HMAC-SHA1)

HMAC-SHA1, as defined in Section 4.2.1, SHALL be the default message authentication code. The default session authentication key-length (na) SHALL be 160 bits, the default authentication tag length (ntag) SHALL be 80 bits, and the SRTPPREFIXLENGTH SHALL be zero for HMAC-SHA1. In addition, for SRTCP, the pre-defined HMAC-SHA1 MUST NOT be applied with a value of ntag, nor na, that are smaller than these defaults. For SRTP, smaller values are NOT RECOMMENDED, but MAY be used after careful consideration of the issues in Section 7.5 and 9.5.
HMAC-SHA1 は、セクション 4.2.1 で定義されるように、デフォルトのメッセージ認証コードでなければなりません。デフォルトセッション認証キー長(N A)160 ビット、デフォルトの認証タグの長さ(N なければならないタグ)80 ビットでなければならない、および SRTP の PREFIX の LENGTH は、 HMAC-SHA1 はゼロでなければなりません。また、 SRTCP のために、予め定義された HMAC-SHA1 は、 n の値を適用してはいけませんタグ、また n はこれらのデフォルト値よりも小さいこと、。 SRTP のために、より小さな値が推奨されていませんが、セクション 7.5 と 9.5 での問題を慎重に考慮して使用することもできます。

## 5.3 。鍵導出:AES-CM PRF (5.3. Key Derivation: AES-CM PRF)

The AES Counter Mode based key derivation and PRF defined in Sections 4.3.1 to 4.3.3, using a 128-bit master key, SHALL be the default method for generating session keys. The default master salt length SHALL be 112 bits and the default key-derivation rate SHALL be zero.
AES カウンタモード基づく鍵導出および PRF は、 128 ビットのマスターキーを使用して、 4.3.1 4.3.3 にセクションで定義され、セッション鍵を生成するための既定の方法でなければなりません。デフォルトマスター塩長は 112 ビットでなければならないとデフォルトのキー導出速度がゼロでなければなりません。

## 6. SRTP 変換を追加 (6. Adding SRTP Transforms)

Section 4 provides examples of the level of detail needed for defining transforms. Whenever a new transform is to be added to SRTP, a companion standard track RFC MUST be written to exactly define how the new transform can be used with SRTP (and SRTCP). Such a companion RFC SHOULD avoid overlap with the SRTP protocol document. Note however, that it MAY be necessary to extend the SRTP or SRTCP cryptographic context definition with new parameters (including fixed or default values), add steps to the packet processing, or even add fields to the SRTP/SRTCP packets. The companion RFC SHALL explain any known issues regarding interactions between the transform and other aspects of SRTP.
セクション 4 は、変換を定義するために必要な詳細レベルの例を提供します。新しい変換たびコンパニオン標準トラック RFC が正確に SRTP(および SRTCP)で使用することができますどのように新しい変換を定義するために書かなければならない、 SRTP に追加されます。このようなコンパニオン RFC は、 SRTP プロトコル文書との重複を避けるべきです。(固定またはデフォルト値を含む)は、新しいパラメータで SRTP または SRTCP 暗号コンテキストの定義を拡張パケット処理にステップを追加、あるいは SRTP / SRTCP パケットにフィールドを追加する必要があるかもしれないことが留意されたいです。コンパニオン RFC は、 SRTP の変換および他の側面の間の相互作用に関する既知の問題を説明しなければなりません。

Each new transform document SHOULD specify its key attributes, e.g., size of keys (minimum, maximum, recommended), format of keys, recommended/required processing of input keying material, requirements/recommendations on key lifetime, re-keying and key derivation, whether sharing of keys between SRTP and SRTCP is allowed or not, etc.
それぞれの新しい変換文書は、鍵の有効期間、再入力し、キー派生の材料、要件/推奨をキーイング入力する例えば、キーのサイズ(最小値、最大値、推奨)、キーの形式、推奨/必要な処理をそのキー属性を指定する必要があります SRTP と SRTCP の間の鍵の共有が許可されているかどうか、など

An added message integrity transform SHOULD define a minimum acceptable key/tag size for SRTCP, equivalent in strength to the minimum values as defined in Section 5.2.
インテグリティ変換追加メッセージは、セクション 5.2 で定義されるような最小値に強度の等価 SRTCP のための最小許容されるキー/タグのサイズを定義する必要があります。

## 7.理論的根拠 (7. Rationale)

This section explains the rationale behind several important features of SRTP.
このセクションでは、 SRTP のいくつかの重要な機能の背後にある理論的根拠を説明しています。

## 7.1 。鍵の導出 (7.1. Key derivation)

Key derivation reduces the burden on the key establishment. As many as six different keys are needed per crypto context (SRTP and SRTCP encryption keys and salts, SRTP and SRTCP authentication keys), but these are derived from a single master key in a cryptographically secure way. Thus, the key management protocol needs to exchange only one master key (plus master salt when required), and then SRTP itself derives all the necessary session keys (via the first, mandatory application of the key derivation function).
鍵導出は、鍵確立の負担を軽減します。などの多くの 6 つの異なる鍵を暗号コンテキスト(SRTP と SRTCP 暗号化キーとの塩、 SRTP と SRTCP 認証キー)ごとに必要とされているが、これらは、暗号的に安全な方法で単一のマスターキーから導出されます。このように、鍵管理プロトコルは、(必要に応じてプラスマスター塩)唯一のマスターキーを交換する必要があり、その後、 SRTP 自体は、(鍵導出関数の最初の、必須のアプリケーションを介して)必要なすべてのセッション鍵を導出します。

Multiple applications of the key derivation function are optional, but will give security benefits when enabled. They prevent an attacker from obtaining large amounts of ciphertext produced by a single fixed session key. If the attacker was able to collect a large amount of ciphertext for a certain session key, he might be helped in mounting certain attacks.
鍵導出関数の複数のアプリケーションがオプションですが、有効にするとセキュリティ上の利点を提供します。彼らは、単一の固定セッションキーによって生成暗号文を大量に取得からの攻撃を防ぎます。攻撃者は、特定のセッションキーの暗号文を大量に集めることができたならば、彼は特定の攻撃を実装する際に役立っている可能性があります。

Multiple applications of the key derivation function provide backwards and forward security in the sense that a compromised session key does not compromise other session keys derived from the same master key. This means that the attacker who is able to recover a certain session key, is anyway not able to have access to messages secured under previous and later session keys (derived from the same master key). (Note that, of course, a leaked master key reveals all the session keys derived from it.)
鍵導出関数の複数のアプリケーションが後方提供し、妥協セッションキーが同じマスターキーから誘導された他のセッションキーを妥協しないという意味でセキュリティを転送します。これは、特定のセッションキーを回復することができる攻撃者は、とにかく(同じマスターキー由来)、前と後のセッションのキーの下に固定したメッセージへのアクセス権を持つことができないことを意味します。(もちろん、漏れたマスターキーはそこから派生したすべてのセッションキーを明らかにする、ということに注意してください。)

Considerations arise with high-rate key refresh, especially in large multicast settings, see Section 11.
検討事項は、特に大規模なマルチキャストの設定で、高レートの鍵リフレッシュして発生し、セクション 11 を参照してください。

## 7.2 。塩漬けキー (7.2. Salting key)

The master salt guarantees security against off-line key-collision attacks on the key derivation that might otherwise reduce the effective key size [MF00].
マスター塩は、それ以外の有効な鍵サイズ[MF00]を減らす可能性がある鍵導出のオフライン鍵衝突攻撃に対する安全性が保証されます。

The derived session salting key used in the encryption, has been introduced to protect against some attacks on additive stream ciphers, see Section 9.2. The explicit inclusion method of the salt in the IV has been selected for ease of hardware implementation.
暗号化に使用するキーを塩漬け派生したセッションは、 9.2 項を参照してください、添加剤のストリーム暗号にいくつかの攻撃から保護するために導入されました。 IV 中の塩の明示的な封入方法は、ハードウェアの実装を容易にするために選択されています。

## 7.3 。ユニバーサルハッシュからのメッセージの完全性 (7.3. Message Integrity from Universal Hashing)

The particular definition of the keystream given in Section 4.1 (the keystream prefix) is to give provision for particular universal hash functions, suitable for message authentication in the Wegman-Carter paradigm [WC81]. Such functions are provably secure, simple, quick, and especially appropriate for Digital Signal Processors and other processors with a fast multiply operation.
セクション 4.1(キーストリームプレフィックス)で与えられたキーストリームの特定の定義はウェッグマン・カーターパラダイム[WC81]におけるメッセージ認証に適した特定の汎用ハッシュ関数の規定を与えることです。このような機能は証明可能安全なシンプル、迅速、かつ高速乗算演算とデジタル信号プロセッサと他のプロセッサに特に適しています。

No authentication transforms are currently provided in SRTP other than HMAC-SHA1. Future transforms, like the above mentioned universal hash functions, MAY be added following the guidelines in Section 6.
認証なしの変換は現在、 HMAC-SHA1 以外 SRTP 他で提供されていません。将来の変換は、前述したユニバーサルハッシュ関数のように、第 6 節のガイドライン次追加される場合があります。

## 7.4 。データ発信元認証の考慮事項 (7.4. Data Origin Authentication Considerations)

Note that in pair-wise communications, integrity and data origin authentication are provided together. However, in group scenarios where the keys are shared between members, the MAC tag only proves that a member of the group sent the packet, but does not prevent against a member impersonating another. Data origin authentication (DOA) for multicast and group RTP sessions is a hard problem that needs a solution; while some promising proposals are being investigated [PCST1] [PCST2], more work is needed to rigorously specify these technologies. Thus SRTP data origin authentication in groups is for further study.
ペアワイズコミュニケーション、整合性とデータ起源認証で一緒に提供されていることに注意してください。しかし、キーがメンバー間で共有されるグループのシナリオでは、 MAC タグは、グループのメンバーは、パケットを送信したが、別の偽装部材に対して妨げないことを証明しています。マルチキャストグループの RTP セッションのためのデータ発信元認証は(DOA)ソリューションを必要とする困難な問題です。いくつかの有望な提案が検討されている間、[PCST1] [PCST2]、より多くの作業が厳密にこれらの技術を特定するために必要とされます。したがって、グループ内の SRTP データ発信元認証は、今後の検討課題です。

DOA can be done otherwise using signatures. However, this has high impact in terms of bandwidth and processing time, therefore we do not offer this form of authentication in the pre-defined packet-integrity transform.
DOA は、そうでない場合は、署名を使用して行うことができます。しかし、これは、したがって、我々は変換事前定義されたパケットの完全性におけるこの形式の認証を提供しない、帯域幅や処理時間の面で高い影響を与えています。

The presence of mixers and translators does not allow data origin authentication in case the RTP payload and/or the RTP header are manipulated. Note that these types of middle entities also disrupt end-to-end confidentiality (as the IV formation depends e.g., on the RTP header preservation). A certain trust model may choose to trust the mixers/translators to decrypt/re-encrypt the media (this would imply breaking the end-to-end security, with related security implications).
ミキサおよびトランスレータの存在は、 RTP ペイロード及び/又は RTP ヘッダが操作された場合に、データ発信元認証を許可しません。(IV 形成が RTP ヘッダの保全上、例えば依存する)中間エンティティのこれらのタイプは、エンドツーエンドの機密性を混乱させることに注意してください。特定の信頼モデルは、復号化/再暗号化する(これは、関連するセキュリティの意味で、エンドツーエンドのセキュリティを破る暗示する)メディアをミキサー/翻訳者を信頼することもできます。

## 7.5 。ショートとゼロ長メッセージ認証 (7.5. Short and Zero-length Message Authentication)

As shown in Figure 1, the authentication tag is RECOMMENDED in SRTP. A full 80-bit authentication-tag SHOULD be used, but a shorter tag or even a zero-length tag (i.e., no message authentication) MAY be used under certain conditions to support either of the following two application environments.
図 1 に示すように、認証タグは、 SRTP で推奨されています。フル 80 ビットの認証タグが使用されるべきであり、より短いタグまたはゼロ長のタグ(すなわち、メッセージ認証)は、以下の 2 つのアプリケーション環境のいずれかをサポートするために、一定の条件の下で使用することはできません。

強力な認証は、帯域幅の保全が不可欠である環境では実用的ではないことができます。重要な特殊なケースでは、帯域幅が希少で高価な資源である無線通信システム、です。研究は、特定のアプリケーションとリンク技術のために、追加のバイトは、スペクトル効率の著しい低下の[SWO]をもたらし得ることを示しています。かなりの努力は、スペクトル効率[RFC3095]を改善するために、 IP ヘッダー圧縮技術を設計するためになされたものです。典型的な音声アプリケーションは、 20 個のバイトのサンプルを生成し、 RTP 、 UDP 及び IP ヘッダが共同的に許容される無線帯域経済[RFC3095]を得るために、平均して 1 または 2 バイトに圧縮される必要があります。この場合には、強力な認証は、ほぼ 50 ％のオーバーヘッドを課します。
認証が原因認証タグに膨張を吸収することができない固定幅フィールドとのデータリンクを使用するアプリケーションのために非実用的です。これは、いくつかの重要な既存の無線チャネルの場合です。例えば、ゼロバイトヘッダ圧縮は、レガシーと EVRC / SMV 音声を適応させるために使用される IS-95 チャネルベアラ CDMA2000 VoIP サービスに。そうではない単一の追加のオクテットが ROHC [RFC3242]のための 0 バイト・プロファイルの作成を動機データに追加することができることがわかりました。
A short tag is secure for a restricted set of applications. Consider a voice telephony application, for example, such as a G.729 audio codec with a 20-millisecond packetization interval, protected by a 32-bit message authentication tag. The likelihood of any given packet being successfully forged is only one in 2^32. Thus an adversary can control no more than 20 milliseconds of audio output during a 994-day period, on average. In contrast, the effect of a single forged packet can be much larger if the application is stateful. A codec that uses relative or predictive compression across packets will propagate the maliciously generated state, affecting a longer duration of output.
短いタグは、アプリケーションの制限されたセットのために安全です。このような 32 ビットメッセージ認証タグによって保護さ 20 ミリ秒のパケット化間隔で G.729 オーディオコーデックとしては、例えば、音声電話アプリケーションを考えます。正常鍛造され、任意の所与のパケットの可能性は、唯一の 2 ^ 32 です。従って敵は平均して 994 日の期間中に音声出力のせいぜい 20 ミリ秒を制御することができます。対照的に、単一の偽造パケットの効果は、アプリケーションがステートフルである場合にはるかに大きくすることができます。パケットを横切って相対的または予測圧縮を使用するコーデックは、出力のより長い持続時間に影響を与える、悪意を持って生成された状態を伝播します。

Certainly not all SRTP or telephony applications meet the criteria for short or zero-length authentication tags. Section 9.5.1 discusses the risks of weak or no message authentication, and section 9.5 describes the circumstances when it is acceptable and when it is unacceptable.
確かに、すべての SRTP またはテレフォニーアプリケーションでは、短期または長さゼロの認証タグのための基準を満たしていません。セクション 9.5.1 は、弱い又は全くメッセージ認証の危険性を説明し、それが許容される場合、それは受け入れられない場合セクション 9.5 は、状況を説明しています。

## 8.キー管理の考慮事項 (8. Key Management Considerations)

There are emerging key management standards [MIKEY] [KEYMGT] [SDMS] for establishing an SRTP cryptographic context (e.g., an SRTP master key). Both proprietary and open-standard key management methods are likely to be used for telephony applications [MIKEY] [KINK] and multicast applications [GDOI]. This section provides guidance for key management systems that service SRTP session.
あり、新興 SRTP 暗号コンテキストを確立するための鍵管理基準[MIKEY] [KEYMGT] [SDMS](例えば、 SRTP マスターキー)。どちらも独自のオープン・スタンダードの鍵管理方法は、テレフォニーアプリケーション[MIKEY] [KINK]およびマルチキャストアプリケーション[GDOI]に使用される可能性が高いです。このセクションでは、サービスの SRTP セッション鍵管理システムのためのガイダンスを提供します。

For initialization, an interoperable SRTP implementation SHOULD be given the SSRC and MAY be given the initial RTP sequence number for the RTP stream by key management (thus, key management has a dependency on RTP operational parameters). Sending the RTP sequence number in the key management may be useful e.g., when the initial sequence number is close to wrapping (to avoid synchronization problems), and to communicate the current sequence number to a joining endpoint (to properly initialize its replay list).
初期化のために、相互運用可能な SRTP 実装は SSRC を与えられるべきであると(従って、鍵管理は RTP 動作パラメータに依存している)鍵管理によって RTP ストリームのための最初の RTP シーケンス番号を与えられてもよいです。初期シーケンス番号は、ラッピングに近い場合、キー管理に RTP シーケンス番号を送信する(同期の問題を回避するため)、および(適切に再生リストを初期化するために)参加エンドポイントに現在のシーケンス番号を通信するために有用な、例えば、であり得ます。

If the pre-defined transforms are used, SRTP allows sharing of the same master key between SRTP/SRTCP streams belonging to the same RTP session.
事前定義された変換が使用される場合、 SRTP は同じ RTP セッションに属する SRTP / SRTCP ストリーム間で同じマスター鍵の共有を可能にします。

First, sharing between SRTP streams belonging to the same RTP session is secure if the design of the synchronization mechanism, i.e., the IV, avoids keystream re-use (the two-time pad, Section 9.1). This is taken care of by the fact that RTP provides for unique SSRCs for streams belonging to the same RTP session. See Section 9.1 for further discussion.
同期メカニズム、すなわち、 IV 、の設計は、キーストリームの再利用(2 回のパッド、第 9.1 節)を回避した場合まず、同じ RTP セッションに属する SRTP ストリーム間で共有することは安全です。これは、 RTP は、同じ RTP セッションに属するストリームのためのユニークな SSRCs のために提供しているという事実によって考慮されます。さらなる議論については、セクション 9.1 を参照してください。

Second, sharing between SRTP and the corresponding SRTCP is secure. The fact that an SRTP stream and its associated SRTCP stream both carry the same SSRC does not constitute a problem for the two-time pad due to the key derivation. Thus, SRTP and SRTCP corresponding to one RTP session MAY share master keys (as they do by default).
第二に、 SRTP と SRTCP 対応するとの共有が安全です。 SRTP ストリームとそれに関連する SRTCP ストリームが同じ SSRC を運ぶ両方という事実は、鍵導出のために 2 回のパッドのための問題を構成しません。(彼らはデフォルトでそうであるように)このように、 1 つの RTP セッションに対応する SRTP と SRTCP は、マスターキーを共有することがあります。

Note that message authentication also has a dependency on SSRC uniqueness that is unrelated to the problem of keystream reuse: SRTP streams authenticated under the same key MUST have a distinct SSRC in order to identify the sender of the message. This requirement is needed because the SSRC is the cryptographically authenticated field used to distinguish between different SRTP streams. Were two streams to use identical SSRC values, then an adversary could substitute messages from one stream into the other without detection.
同じキーの下で認証された SRTP ストリームは、メッセージの送信者を識別するために別個の SSRC を持つ必要があります。そのメッセージ認証はまた、鍵ストリームの再利用の問題とは無関係である SSRC の一意性に依存している(注)。 SSRC は異なる SRTP ストリームを区別するために使用される暗号的に認証されたフィールドであるため、この要件が必要とされています。二つの流れが同じ SSRC 値を使用するようにし、その後、敵対者は検出されず、他に一つのストリームからメッセージに置き換え可能性があります。

SRTP/SRTCP MUST NOT share master keys under any other circumstances than the ones given above, i.e., between SRTP and its corresponding SRTCP, and, between streams belonging to the same RTP session.
SRTP / SRTCP は同じ RTP セッションに属するストリーム間、 SRTP とその対応する SRTCP との間に存在与えられたもの、すなわち、以外の状況下でマスターキーを共有し、してはいけません。

## 8.1 。再キーイング (8.1. Re-keying)

The recommended way for a particular key management system to provide re-key within SRTP is by associating a master key in a crypto context with an MKI.
SRTP 内再鍵を提供するために特定の鍵管理システムのための推奨される方法は、 MKI と暗号コンテキストのマスタキーを関連付けることです。

This provides for easy master key retrieval (see Scenarios in Section 11), but has the disadvantage of adding extra bits to each packet. As noted in Section 7.5, some wireless links do not cater for added bits, therefore SRTP also defines a more economic way of triggering re-keying, via use of <From, To>, which works in some specific, simple scenarios (see Section 8.1.1).
これは簡単なマスターキー検索(セクション 11 でシナリオを参照)を提供するが、各パケットに余分なビットを追加するという欠点を有します。 7.5 節で述べたように、いくつかの無線リンクは、したがって、 SRTP はまた、(項を参照いくつかの特定の、単純なシナリオで動作している、<ために、より>の使用を介して、再キーイングを誘発するより経済的な方法を定義し、追加ビットに応じるありません 8.1.1)。

SRTP senders SHALL count the amount of SRTP and SRTCP traffic being used for a master key and invoke key management to re-key if needed (Section 9.2). These interactions are defined by the key management interface to SRTP and are not defined by this protocol specification.
SRTP の送信者は、(9.2 節)をマスターキーのために使用されて SRTP と SRTCP トラフィックの量をカウントし、必要に応じて再キーに鍵管理を起動するものとします。これらの相互作用は、 SRTP 鍵管理インタフェースによって定義され、このプロトコル仕様で定義されていません。

## 8.1.1 。再入力のための<に、から>の使用 (8.1.1. Use of the <From, To> for re-keying)

In addition to the use of the MKI, SRTP defines another optional mechanism for master key retrieval, the <From, To>. The <From, To> specifies the range of SRTP indices (a pair of sequence number and ROC) within which a certain master key is valid, and is (when used) part of the crypto context. By looking at the 48-bit SRTP index of the current SRTP packet, the corresponding master key can be found by determining which From-To interval it belongs to. For SRTCP, the most recently observed/used SRTP index (which can be obtained from the cryptographic context) is used for this purpose, even though SRTCP has its own (31-bit) index (see caveat below).
MKI の使用に加えて、 SRTP は、<、から>、マスター鍵の検索のために別の任意の機構を定義しています。(使用する場合)、特定のマスターキーは、暗号コンテキストの一部有効であり、ある範囲内 SRTP インデックスの範囲(シーケンス番号及び ROC のペア)を指定し、<に、より>。現在の SRTP パケットの 48 ビットの SRTP インデックスを見て、対応するマスターキーは、以下から-することが属する区間かを決定することによって求めることができます。 SRTCP のために、(暗号コンテキストから入手可能)最近観察された/使用 SRTP インデックスは、 SRTCP は、独自の(31 ビット)、インデックス(警告下記参照)を有しているにもかかわらず、この目的のために使用されます。

This method, compared to the MKI, has the advantage of identifying the master key and defining its lifetime without adding extra bits to each packet. This could be useful, as already noted, for some wireless links that do not cater for added bits. However, its use SHOULD be limited to specific, very simple scenarios. We recommend to limit its use when the RTP session is a simple unidirectional or bi-directional stream. This is because in case of multiple streams, it is difficult to trigger the re-key based on the <From, To> of a single RTP stream. For example, if several streams share a master key, there is no simple one-to-one correspondence between the index sequence space of a certain stream, and the index sequence space on which the <From, To> values are based. Consequently, when a master key is shared between streams, one of these streams MUST be designated by key management as the one whose index space defines the re-keying points. Also, the re-key triggering on SRTCP is based on the correspondent SRTP stream, i.e., when the SRTP stream changes the master key, so does the correspondent SRTCP. This becomes obviously more and more complex with multiple streams.
この方法は、 MKI と比較して、マスターキーを識別し、各パケットに余分なビットを追加することなく、その寿命を規定するという利点を有します。すでに述べたように、これは追加のビットを世話していないいくつかの無線リンクのために、役に立つかもしれません。しかし、その使用は、特定の、非常に単純なシナリオに限定されるべきです。 RTP セッションは、単純な単方向または双方向ストリームであるとき、私たちは、その使用を制限することをお勧めします。複数のストリームの場合には、単一 RTP ストリームの<にから、>に基づいて再キーをトリガすることが困難であるためです。複数のストリームは、マスターキーを共有する場合、例えば、特定のストリームのインデックスシーケンススペース、および値<へ、から>が基づくインデックスシーケンススペースとの間には単純な 1 対 1 の対応が存在しません。これにより、マスターキーはストリーム間で共有される場合、これらのストリームのうちの 1 つは、その索引空間再キーイング点を定義する一つとして、鍵管理によって指定されなければなりません。また、 SRTCP にトリガの再キーは、 SRTP ストリームは、マスターキーを変更し、その対応の SRTCP を行うとき、すなわち、対応の SRTP ストリームに基づいています。これは明らかに複数のストリームを持つ、ますます複雑になってしまいます。

The default values for the <From, To> are "from the first observed packet" and "until further notice". However, the maximum limit of SRTP/SRTCP packets that are sent under each given master/session key (Section 9.2) MUST NOT be exceeded.
<へ、から>のデフォルト値は、「最初の観測されたパケットから」と「追って通知があるまで」です。しかし、各所与のマスタ/セッションキー(セクション 9.2)の下で送信される SRTP / SRTCP パケットの最大限界が超えてはなりません。

In case the <From, To> is used as key retrieval, then the MKI is not inserted in the packet (and its indicator in the crypto context is zero). However, using the MKI does not exclude using <From, To> key lifetime simultaneously. This can for instance be useful to signal at the sender side at which point in time an MKI is to be made active.
場合<へ、から>キー検索として使用され、その後、 MKI は、パケットに挿入されていない(と暗号コンテキストにおけるその指標はゼロです)。しかし、 MKI を使用すると同時に、キー寿命<に、より>を使用して排除するものではありません。これは、例えば、 MKI がアクティブにされる時間内にその時点で送信側での信号のに有用です。

## 8.2 。キー管理パラメータ (8.2. Key Management parameters)

The table below lists all SRTP parameters that key management can supply. For reference, it also provides a summary of the default and mandatory-to-support values for an SRTP implementation as described in Section 5.
以下の表は、キー管理を供給することができ、すべての SRTP パラメータを示します。セクション 5 に記載されているように参照のために、それはまた、 SRTP 実装のデフォルトと強制的にサポート値の要約を提供します。

```
Parameter                     Mandatory-to-support    Default
---------                     --------------------    -------

SRTP and SRTCP encr transf.       AES_CM, NULL         AES_CM
(Other possible values: AES_f8)

SRTP and SRTCP auth transf.       HMAC-SHA1           HMAC-SHA1

SRTP and SRTCP auth params:
  n_tag (tag length)                 80                 80
  SRTP prefix_length                  0                  0

Key derivation PRF                 AES_CM              AES_CM

Key material params
(for each master key):
  master key length                 128                128
  n_e (encr session key length)     128                128
  n_a (auth session key length)     160                160
  master salt key
  length of the master salt         112                112
  n_s (session salt key length)     112                112
  key derivation rate                 0                  0

  key lifetime
     SRTP-packets-max-lifetime      2^48               2^48
     SRTCP-packets-max-lifetime     2^31               2^31
     from-to-lifetime <From, To>
  MKI indicator                       0                 0
  length of the MKI                   0                 0
  value of the MKI

Crypto context index params:
  SSRC value
  ROC
  SEQ
  SRTCP Index
  Transport address
  Port number

Relation to other RTP profiles:
  sender's order between FEC and SRTP FEC-SRTP      FEC-SRTP
  (see Section 10)
```

## 9.セキュリティの考慮事項 (9. Security Considerations)

## 9.1 。 SSRC の衝突と二度のパッド (9.1. SSRC collision and two-time pad)

Any fixed keystream output, generated from the same key and index MUST only be used to encrypt once. Re-using such keystream (jokingly called a "two-time pad" system by cryptographers), can seriously compromise security. The NSA's VENONA project [C99] provides a historical example of such a compromise. It is REQUIRED that automatic key management be used for establishing and maintaining SRTP and SRTCP keying material; this requirement is to avoid keystream reuse, which is more likely to occur with manual key management. Furthermore, in SRTP, a "two-time pad" is avoided by requiring the key, or some other parameter of cryptographic significance, to be unique per RTP/RTCP stream and packet. The pre- defined SRTP transforms accomplish packet-uniqueness by including the packet index and stream-uniqueness by inclusion of the SSRC.
同じキーとインデックスから生成された固定されたキーストリーム出力は、一度だけ暗号化するために使用されなければなりません。再使用して、このようなキーストリームを真剣にセキュリティを脅かすことができ、(冗談めかして暗号学者による「二度のパッド」システムと呼ばれます)。 NSA のベノナ[C99]は、そのような妥協の歴史的例を提供します。自動鍵管理を確立し、 SRTP を維持し、 SRTCP は、材料を合わせるために使用することが要求されます。この要件は、手動鍵管理で発生する可能性が高くなり、キーストリーム再利用を、回避することです。また、 SRTP では、「二時間パッドは」 RTP / RTCP ストリームとパケットごとに一意であることが、鍵、または暗号重要ないくつかの他のパラメータを要求することによって回避されます。

The pre-defined transforms (AES-CM and AES-f8) allow master keys to be shared across streams belonging to the same RTP session by the inclusion of the SSRC in the IV. A master key MUST NOT be shared among different RTP sessions.
事前定義された変換(AES-CM および AES-F8)は、マスターキーが IV における SSRC を含めることによって、同じ RTP セッションに属するストリーム間で共有されることを可能にします。マスターキーは、異なる RTP セッションの間で共有されてはいけません。

Thus, the SSRC MUST be unique between all the RTP streams within the same RTP session that share the same master key. RTP itself provides an algorithm for detecting SSRC collisions within the same RTP session. Thus, temporary collisions could lead to temporary two-time pad, in the unfortunate event that SSRCs collide at a point in time when the streams also have identical sequence numbers (occurring with probability roughly 2^(-48)). Therefore, the key management SHOULD take care of avoiding such SSRC collisions by including the SSRCs to be used in the session as negotiation parameters, proactively assuring their uniqueness. This is a strong requirements in scenarios where for example, there are multiple senders that can start to transmit simultaneously, before SSRC collision are detected at the RTP level.
このように、 SSRC は同じマスターキーを共有し、同じ RTP セッション内のすべての RTP ストリームの間でユニークでなければなりません。 RTP 自体は同じ RTP セッション内 SSRC 衝突を検出するためのアルゴリズムを提供します。このように、一時的な衝突がストリームも同じシーケンス番号を有する場合 SSRCs の時点で衝突する不幸な出来事では、一時的な 2 回のパッドにつながる可能性(確率で発生する約 2 ^( - 48))。そのため、鍵の管理は、積極的に自分の一意性を確保し、交渉のパラメータとしてセッションで使用する SSRCs を含むことによって、このような SSRC 衝突を回避の世話をする必要があります。これは、例えば、 SSRC 衝突が RTP レベルで検出される前に、同時に送信を開始することができる複数の送信者が存在するシナリオで強い要求です。

Note also that even with distinct SSRCs, extensive use of the same key might improve chances of probabilistic collision and time- memory-tradeoff attacks succeeding.
それさえも明確な SSRCs で、同じキーの広範な使用は、確率的衝突し、後続のタイムメモリトレードオフ攻撃の可能性を向上させる可能性があるにも注意してください。

As described, master keys MAY be shared between streams belonging to the same RTP session, but it is RECOMMENDED that each SSRC have its own master key. When master keys are shared among SSRC participants and SSRCs are managed by a key management module as recommended above, the RECOMMENDED policy for an SSRC collision error is for the participant to leave the SRTP session as it is a sign of malfunction.
このように、マスターキーは同じ RTP セッションに属するストリーム間で共有されるかもしれないが、各 SSRC は独自のマスターキーを持っていることが推奨されます。マスターキーは SSRC 参加者間で共有されており、上記の推奨よう SSRCs は、鍵管理モジュールによって管理されている場合は、 SSRC 衝突エラーのために推奨ポリシーは、それが故障の兆候があるとして、参加者が SRTP セッションを終了するのです。

## 9.2 。キー使用法 (9.2. Key Usage)

The effective key size is determined (upper bounded) by the size of the master key and, for encryption, the size of the salting key. Any additive stream cipher is vulnerable to attacks that use statistical knowledge about the plaintext source to enable key collision and time-memory tradeoff attacks [MF00] [H80] [BS00]. These attacks take advantage of commonalities among plaintexts, and provide a way for a cryptanalyst to amortize the computational effort of decryption over many keys, or over many bytes of output, thus reducing the effective key size of the cipher. A detailed analysis of these attacks and their applicability to the encryption of Internet traffic is provided in [MF00]. In summary, the effective key size of SRTP when used in a security system in which m distinct keys are used, is equal to the key size of the cipher less the logarithm (base two) of m. Protection against such attacks can be provided simply by increasing the size of the keys used, which here can be accomplished by the use of the salting key. Note that the salting key MUST be random but MAY be public. A salt size of (the suggested) size 112 bits protects against attacks in scenarios where at most 2^112 keys are in use. This is sufficient for all practical purposes.
暗号化のための有効なキーのマスターキーのサイズによって決定されるサイズ(上部境界)と、塩析キーのサイズ。任意の添加ストリーム暗号は、[H80] [BS00] [MF00]キー衝突と時間メモリトレードオフ攻撃を可能にするために、平文源に関する統計知識を使用する攻撃に対して脆弱です。これらの攻撃は、平文の間で共通点を活用するため、暗号の有効な鍵サイズを小さく、多くのキーの上に、または出力のバイト数を超える復号化の計算量を償却するために暗号解読のための方法を提供します。これらの攻撃とインターネットトラフィックの暗号化への適用の詳細な分析は、[MF00]で提供されています。要約すると、 SRTP の実効キー・サイズは、 M 個の異なるキーが使用されているセキュリティシステムで使用される場合、 M の暗号鍵のサイズより少ない対数(基数 2)に等しいです。このような攻撃に対する保護は塩漬けキーを使用することによって達成することができ、ここで使用されるキーのサイズを大きくするだけで提供することができます。塩漬けキーがランダムでなければなりませんが、公共のことかもしれないことに注意してください。(推奨)サイズ 112 ビットの塩の大きさは、最大で 2 ^ 112 のキーが使用されているシナリオで攻撃から保護します。これは、すべての実用的な目的のためには十分です。

Implementations SHOULD use keys that are as large as possible. Please note that in many cases increasing the key size of a cipher does not affect the throughput of that cipher.
実装はできるだけ大きいキーを使用する必要があります。多くの場合、暗号のキーサイズを大きくすると、その暗号のスループットに影響を与えませんのでご注意ください。

The use of the SRTP and SRTCP indices in the pre-defined transforms fixes the maximum number of packets that can be secured with the same key. This limit is fixed to 2^48 SRTP packets for an SRTP stream, and 2^31 SRTCP packets, when SRTP and SRTCP are considered independently. Due to for example re-keying, reaching this limit may or may not coincide with wrapping of the indices, and thus the sender MUST keep packet counts. However, when the session keys for related SRTP and SRTCP streams are derived from the same master key (the default behavior, Section 4.3), the upper bound that has to be considered is in practice the minimum of the two quantities. That is, when 2^48 SRTP packets or 2^31 SRTCP packets have been secured with the same key (whichever occurs before), the key management MUST be called to provide new master key(s) (previously stored and used keys MUST NOT be used again), or the session MUST be terminated. If a sender of RTCP discovers that the sender of SRTP (or SRTCP) has not updated the master or session key prior to sending 2^48 SRTP (or 2^31 SRTCP) packets belonging to the same SRTP (SRTCP) stream, it is up to the security policy of the RTCP sender how to behave, e.g., whether an RTCP BYE-packet should be sent and/or if the event should be logged.
事前定義された変換における SRTP と SRTCP インデックスの使用は、同じキーで固定することができるパケットの最大数を固定します。この制限は、 SRTP と SRTCP は、独立して考慮される SRTP ストリームのための 2 ^ 48 SRTP パケット、及び 2 ^ 31 SRTCP パケットに固定されています。例えば再キーイングに、この制限に到達すると、またはインデックスのラッピングと一致してもしなくてもよいので、送信側はパケットカウントを保持しなければなりません。関連 SRTP と SRTCP ストリームのためのセッションキーを考慮しなければならない同一のマスターキー(デフォルト動作、セクション 4.3)、上限に由来する場合しかし、二つの量の最小値は、実際にあります。場合 2 ^ 48 SRTP パケットまたは 2 ^ 31 SRTCP パケットが(前に起こる方)同じキーで固定されていることがあり、鍵管理が新しいマスターキー(複数可)を提供するために呼ばれなければなりません(以前に保存され、使用されるキーを再使用してはいけません)、またはセッションが終了しなければなりません。 RTCP の送信者は、 SRTP(または SRTCP)の送信者が前 2 ^ 48 SRTP(または 2 ^ 31 SRTCP)同じ SRTP(SRTCP)ストリームに属するパケットを送信するマスタまたはセッション鍵を更新されていません、それがあることを発見した場合 RTCP BYE パケットは、イベントをログに記録する必要がある、および/または場合は送信されるべきかどうか、例えば、動作するようにどのように RTCP 送信者のセキュリティポリシーまで。

Note: in most typical applications (assuming at least one RTCP packet for every 128,000 RTP packets), it will be the SRTCP index that first reaches the upper limit, although the time until this occurs is very long: even at 200 SRTCP packets/sec, the 2^31 index space of SRTCP is enough to secure approximately 4 months of communication.
注:偶数 200 の SRTCP パケットで/秒:これが発生するまでの時間が非常に長いが最も典型的な用途では、それが最初に上限に達し SRTCP インデックスであろう(すべて 128,000 RTP パケット用の少なくとも一つの RTCP パケットを仮定) 、 SRTCP の 2 ​​^ 31 インデックス空間は、通信の約 4 ヶ月を確保するのに十分です。

Note that if the master key is to be shared between SRTP streams within the same RTP session (Section 9.1), although the above bounds are on a per stream (i.e., per SSRC) basis, the sender MUST base re- key decision on the stream whose sequence number space is the first to be exhausted.
マスターキーが同じ RTP セッション(セクション 9.1)内 SRTP ストリーム間で共有される場合ことに注意し、上記境界は、ストリームごと(すなわち、 SSRC 当り)基準であるが、送信者が上に再キー決定を基づかなければなりませんそのシーケンス番号スペースストリームが枯渇することが最初です。

Key derivation limits the amount of plaintext that is encrypted with a fixed session key, and made available to an attacker for analysis, but key derivation does not extend the master key's lifetime. To see this, simply consider our requirements to avoid two-time pad: two distinct packets MUST either be processed with distinct IVs, or with distinct session keys, and both the distinctness of IV and of the session keys are (for the pre-defined transforms) dependent on the distinctness of the packet indices.
鍵導出は、固定されたセッション鍵で暗号化された平文の量を制限し、分析のために、攻撃者が利用できるように、しかし、鍵導出は、マスターキーの有効期間を延長しません。単純に二度のパッドを避けるために、当社の要件を検討し、これを確認するには次の 2 つの異なるパケットがいずれかの異なる IV を用いて処理、または個別のセッションキーを使用して、および IV のセッションキーの明瞭両方なければならない事前定義されたため(ありますパケットインデックスの明瞭に)依存して変換します。

Note that with the key derivation, the effective key size is at most that of the master key, even if the derived session key is considerably longer. With the pre-defined authentication transform, the session authentication key is 160 bits, but the master key by default is only 128 bits. This design choice was made to comply with certain recommendations in [RFC2104] so that an existing HMAC implementation can be plugged into SRTP without problems. Since the default tag size is 80 bits, it is, for the applications in mind, also considered acceptable from security point of view. Users having concerns about this are RECOMMENDED to instead use a 192 bit master key in the key derivation. It was, however, chosen not to mandate 192-bit keys since existing AES implementations to be used in the key-derivation may not always support key-lengths other than 128 bits. Since AES is not defined (or properly analyzed) for use with 160 bit keys it is NOT RECOMMENDED that ad-hoc key-padding schemes are used to pad shorter keys to 192 or 256 bits.
鍵導出して、効果的なキーのサイズが派生セッションキーはかなり長い場合でも、ほとんどのマスターキーのそれであることに注意してください。事前定義された認証変換では、セッション認証キーは 160 ビットですが、デフォルトではマスターキーは 128 ビットです。この設計の選択は、既存の HMAC の実装が問題なく SRTP に差し込むことができるように、[RFC2104]で特定の勧告に準拠するために作られました。デフォルトタグのサイズは、念頭に置いてアプリケーションのための 80 ビット、それは、あるので、また、セキュリティの観点から許容されると見なさ。このことについて懸念を持つユーザーは、代わりに鍵導出で 192 ビットのマスターキーを使用することをお勧めします。しかし、でした、キー導出に使用される既存の AES 実装は常に 128 ビット以外の鍵の長さをサポートしなくてもよいので、 192 ビットキーを強制しないことを選択。 AES は、 160 ビットの鍵で使用するために定義された(または適切分析)されていないので、アドホック鍵パディングスキームは 192 または 256 ビットにパッドより短いキーに使用されることが推奨されません。

## 9.3 。 RTP ペイロードの機密性 (9.3. Confidentiality of the RTP Payload)

SRTP's pre-defined ciphers are "seekable" stream ciphers, i.e., ciphers able to efficiently seek to arbitrary locations in their keystream (so that the encryption or decryption of one packet does not depend on preceding packets). By using seekable stream ciphers, SRTP avoids the denial of service attacks that are possible on stream ciphers that lack this property. It is important to be aware that, as with any stream cipher, the exact length of the payload is revealed by the encryption. This means that it may be possible to deduce certain "formatting bits" of the payload, as the length of the codec output might vary due to certain parameter settings etc. This, in turn, implies that the corresponding bit of the keystream can be deduced. However, if the stream cipher is secure (counter mode and f8 are provably secure under certain assumptions [BDJR] [KSYH] [IK]), knowledge of a few bits of the keystream will not aid an attacker in predicting subsequent keystream bits. Thus, the payload length (and information deducible from this) will leak, but nothing else.
SRTP の事前定義された暗号が「シーク可能な」ストリーム暗号、すなわち、効率的にキーストリーム内の任意の場所に求めることができる暗号(1 つのパケットの暗号化や復号化は、パケットの前には依存しないように)しています。シーク可能なストリーム暗号を使用することにより、 SRTP は、この特性を持たないストリーム暗号に可能なサービス拒否攻撃を回避することができます。任意のストリーム暗号のように、ペイロードの正確な長さは、暗号化によって明らかにされることを認識することが重要です。これは、等により、この特定のパラメータの設定に変わるかもしれないコーデック出力の長さ、ペイロードの特定の「フォーマットのビットを」推測することが可能であり得ることを意味し、今度は、キーストリームの対応するビットを推定することができることを意味。しかしながら、ストリーム暗号は、セキュアである場合(カウンタモードと F8 一定の仮定[BDJR] [KSYH] [IK]の下に証明可能に安全である)、キーストリームの数ビットの知識は、その後のキーストリームビットを予測する際に攻撃者を支援しないであろう。このように、ペイロード長(と、この推論からの情報)が漏洩しないでしょうが、何も。

As some RTP packet could contain highly predictable data, e.g., SID, it is important to use a cipher designed to resist known plaintext attacks (which is the current practice).
いくつかの RTP パケットは非常に予測可能なデータが含まれている可能性としては、例えば、 SID は、(現在の慣行である)クリブに抵抗するために設計された暗号を使用することが重要です。

## 9.4 。 RTP ヘッダーの機密性 (9.4. Confidentiality of the RTP Header)

In SRTP, RTP headers are sent in the clear to allow for header compression. This means that data such as payload type, synchronization source identifier, and timestamp are available to an eavesdropper. Moreover, since RTP allows for future extensions of headers, we cannot foresee what kind of possibly sensitive information might also be "leaked".
SRTP は、 RTP ヘッダは、ヘッダ圧縮を可能にするために平文で送信されます。これは、ペイロードタイプ、同期ソース識別子およびタイムスタンプなどのデータが盗聴者に利用可能であることを意味します。 RTP は、ヘッダの将来の拡張が可能になりますので、我々はまた、「漏れた」かもしれない可能性が機密情報の種類を予見することはできません。

SRTP is a low-cost method, which allows header compression to reduce bandwidth. It is up to the endpoints' policies to decide about the security protocol to employ. If one really needs to protect headers, and is allowed to do so by the surrounding environment, then one should also look at alternatives, e.g., IPsec [RFC2401].
SRTP は、ヘッダ圧縮は、帯域幅を削減することを可能にする低コストの方法です。それは採用するセキュリティプロトコルについて決定するエンドポイントの政策次第です。 1 は本当にヘッダを保護する必要があり、周囲の環境によってそうすることを許可されている場合は、 1 にも、例えば、代替案での IPsec [RFC2401]を見なければなりません。

## 9.5 。 RTP ペイロードとヘッダの完全性 (9.5. Integrity of the RTP payload and header)

SRTP messages are subject to attacks on their integrity and source identification, and these risks are discussed in Section 9.5.1. To protect against these attacks, each SRTP stream SHOULD be protected by HMAC-SHA1 [RFC2104] with an 80-bit output tag and a 160-bit key, or a message authentication code with equivalent strength. Secure RTP SHOULD NOT be used without message authentication, except under the circumstances described in this section. It is important to note that encryption algorithms, including AES Counter Mode and f8, do not provide message authentication. SRTCP MUST NOT be used with weak (or NULL) authentication.
SRTP メッセージは彼らの整合性とソース識別への攻撃の対象となり、これらのリスクは、 9.5.1 項で説明されています。これらの攻撃から保護するために、各 SRTP ストリームは、 80 ビットの出力タグと 160 ビットキー、または同等の強度を有するメッセージ認証コードと HMAC-SHA1 [RFC2104]によって保護されるべきです。セキュア RTP は、このセクションで説明する状況下を除いて、メッセージ認証なしで使用されるべきではありません。メッセージ認証を提供しない、 AES カウンタモードと f8 を含め、その暗号化アルゴリズムを、注意することが重要です。 SRTCP は弱い(または NULL)認証で使用してはいけません。

SRTP MAY be used with weak authentication (e.g., a 32-bit authentication tag), or with no authentication (the NULL authentication algorithm). These options allow SRTP to be used to provide confidentiality in situations where
SRTP は、弱い認証(例えば、 32 ビットの認証タグ)を有する、または認証なし(NULL 認証アルゴリズム)と共に使用することができます。これらのオプションは、 SRTP が状況で機密性を提供するために使用することができるようにします

weak or null authentication is an acceptable security risk, and
弱いかヌルの認証は、許容可能なセキュリティリスクであり、

it is impractical to provide strong message authentication.
強力なメッセージ認証を提供することは非現実的です。

These conditions are described below and in Section 7.5. Note that both conditions MUST hold in order for weak or null authentication to be used. The risks associated with exercising the weak or null authentication options need to be considered by a security audit prior to their use for a particular application or environment given the risks, which are discussed in Section 9.5.1.
これらの条件は、以下およびセクション 7.5 に記載されています。両方の条件は、使用する弱または null 認証のために保持しなければならないことに留意されたいです。弱いかヌルの認証オプションの行使に関連するリスクは、前のセクション 9.5.1 に記載されているリスク所与の特定の用途または環境のためのそれらの使用に関するセキュリティ監査によって考慮される必要があります。

Weak authentication is acceptable when the RTP application is such that the effect of a small fraction of successful forgeries is negligible. If the application is stateless, then the effect of a single forged RTP packet is limited to the decoding of that particular packet. Under this condition, the size of the authentication tag MUST ensure that only a negligible fraction of the packets passed to the RTP application by the SRTP receiver can be forgeries. This fraction is negligible when an adversary, if given control of the forged packets, is not able to make a significant impact on the output of the RTP application (see the example of Section 7.5).
RTP アプリケーションが成功した偽造の小画分の効果が無視できるようなものである場合、弱い認証が許容されます。アプリケーションがステートレスである場合には、単一の偽造 RTP パケットの効果は、特定のパケットの復号化に限定されます。この状態で、認証タグのサイズは、 SRTP 受信機によって RTP アプリケーションに渡されたパケットのごくわずかな割合が偽造であることを保証しなければなりません。敵対者が、偽造パケットの制御を与えられた場合、(セクション 7.5 の例を参照)RTP アプリケーションの出力に大きな影響を行うことができない場合。この画分は無視できます

Weak or null authentication MAY be acceptable when it is unlikely that an adversary can modify ciphertext so that it decrypts to an intelligible value. One important case is when it is difficult for an adversary to acquire the RTP plaintext data, since for many codecs, an adversary that does not know the input signal cannot manipulate the output signal in a controlled way. In many cases it may be difficult for the adversary to determine the actual value of the plaintext. For example, a hidden snooping device might be required in order to know a live audio or video signal. The adversary's signal must have a quality equivalent to or greater than that of the signal under attack, since otherwise the adversary would not have enough information to encode that signal with the codec used by the victim. Plaintext prediction may also be especially difficult for an interactive application such as a telephone call.
分かりやすい値に復号化するように敵が暗号文を修正することができるとは考えにくいとき弱いかヌル認証が許容可能です。それは、多くのコーデックのために、入力信号を知らない敵が制御された方法で出力信号を操作することができないので、 RTP 平文データを取得するために敵のために困難であるとき、一つの重要なケースがあります。敵対者は、平文の実際の値を決定するために多くの場合、困難であり得ます。たとえば、隠しスヌーピングデバイスは、ライブオーディオまたはビデオ信号を知るために必要になることがあります。それ以外の場合は攻撃者が被害者によって使用されるコーデックでその信号を符号化するのに十分な情報を持っていないので、敵の信号は、攻撃対象の信号よりも品質と同等またはそれ以上を持っている必要があります。

Weak or null authentication MUST NOT be used when the RTP application makes data forwarding or access control decisions based on the RTP data. In such a case, an attacker may be able to subvert confidentiality by causing the receiver to forward data to an attacker. See Section 3 of [B96] for a real-life example of such attacks.
RTP アプリケーションが RTP データに基づいて、データの転送やアクセス制御の決定をする際に弱いかヌルの認証を使用してはいけません。このような場合、攻撃者は、攻撃者にデータを転送するための受信機を引き起こすことによって機密性を破壊することができるかもしれません。このような攻撃の実生活例えば[B96]のセクション 3 を参照してください。

Null authentication MUST NOT be used when a replay attack, in which an adversary stores packets then replays them later in the session, could have a non-negligible impact on the receiver. An example of a successful replay attack is the storing of the output of a surveillance camera for a period of time, later followed by the injection of that output to the monitoring station to avoid surveillance. Encryption does not protect against this attack, and non-null authentication is REQUIRED in order to defeat it.
ヌル認証は、その後に敵格納パケット場合リプレイ攻撃を、使用してはいけません後のセッションでそれらを再生し、レシーバに無視できない影響を与える可能性があります。成功したリプレイ攻撃の例は、後に監視を回避するために、監視ステーションへの出力の注射に続いて、一定期間のための監視カメラの出力を記憶しています。暗号化は、この攻撃を防御しないと、 null 以外の認証は、それを倒すために必要とされます。

If existential message forgery is an issue, i.e., when the accuracy of the received data is of non-negligible importance, null authentication MUST NOT be used.
実存メッセージ偽造が問題である場合は、受信したデータの精度が無視できない重要なものであるとき、すなわち、ヌル認証を使用してはいけません。

## 9.5.1 。弱いかヌルメッセージ認証のリスク (9.5.1. Risks of Weak or Null Message Authentication)

During a security audit considering the use of weak or null authentication, it is important to keep in mind the following attacks which are possible when no message authentication algorithm is used.
弱いかヌルの認証の使用を考慮し、セキュリティ監査時には、心の中で何のメッセージ認証アルゴリズムが使用されていない時に可能な次の攻撃を保つことが重要です。

An attacker who cannot predict the plaintext is still always able to modify the message sent between the sender and the receiver so that it decrypts to a random plaintext value, or to send a stream of bogus packets to the receiver that will decrypt to random plaintext values. This attack is essentially a denial of service attack, though in the absence of message authentication, the RTP application will have inputs that are bit-wise correlated with the true value. Some multimedia codecs and common operating systems will crash when such data are accepted as valid video data. This denial of service attack may be a much larger threat than that due to an attacker dropping, delaying, or re-ordering packets.
平文を予測することができない攻撃者は、常にまだそれがランダムな平文の値に復号化するように、送信者と受信者の間で送信されるメッセージを変更する、またはランダム平文の値に復号化されます受信機に偽のパケットのストリームを送信することが可能です。メッセージ認証が存在しない場合に、 RTP アプリケーションは、ビット単位の真の値と相関している入力を持つことになりますけれども、この攻撃は、基本的にサービス拒否攻撃です。このようなデータが有効なビデオデータとして受け入れられている場合、一部のマルチメディアコーデックと共通のオペレーティングシステムがクラッシュします。サービス攻撃のこの拒否は、遅延、または再順序付けパケット、による攻撃落下に比べてはるかに大きい脅威かもしれません。

An attacker who cannot predict the plaintext can still replay a previous message with certainty that the receiver will accept it. Applications with stateless codecs might be robust against this type of attack, but for other, more complex applications these attacks may be far more grave.
平文を予測することができない攻撃者がまだ受信機はそれを受け入れるだろう確実に前のメッセージを再生することができます。ステートレスコーデックを使用するアプリケーションは、この種の攻撃に対してロバストであるかもしれないが、他の、より複雑なアプリケーションのためにこれらの攻撃は、はるかに深刻なことがあります。

An attacker who can predict the plaintext can modify the ciphertext so that it will decrypt to any value of her choosing. With an additive stream cipher, an attacker will always be able to change individual bits.
それは彼女が選んだの任意の値に復号化するように平文を予測できる攻撃者は、暗号文を変更することができます。添加物ストリーム暗号を使用すると、攻撃者は、常に個々のビットを変更することができます。

An attacker may be able to subvert confidentiality due to the lack of authentication when a data forwarding or access control decision is made on decrypted but unauthenticated plaintext. This is because the receiver may be fooled into forwarding data to an attacker, leading to an indirect breach of confidentiality (see Section 3 of [B96]). This is because data-forwarding decisions are made on the decrypted plaintext; information in the plaintext will determine to what subnet (or process) the plaintext is forwarded in ESP [RFC2401] tunnel mode (respectively, transport mode). When Secure RTP is used without message authentication, it should be verified that the application does not make data forwarding or access control decisions based on the decrypted plaintext.
攻撃者は、データ転送やアクセス制御の決定は、復号化されたが、認証されていない平文で行われたときによる認証の不足のために機密性を破壊することができるかもしれません。受信機は、機密性の間接的な侵害につながる、攻撃者に転送するデータにだまされてもよいからである([B96]のセクション 3 を参照)。データ転送の決定は、復号された平文で行われているためです。平文の情報は平文が ESP [RFC2401]トンネルモード(それぞれ、トランスポートモード)で転送されているもののサブネット(またはプロセス)に決定します。セキュア RTP は、メッセージ認証なしで使用される場合、アプリケーションが復号された平文に基づいて、データの転送やアクセス制御の決定をしないことを確認する必要があります。

Some cipher modes of operation that require padding, e.g., standard cipher block chaining (CBC) are very sensitive to attacks on confidentiality if certain padding types are used in the absence of integrity. The attack [V02] shows that this is indeed the case for the standard RTP padding as discussed in reference to Figure 1, when used together with CBC mode. Later transform additions to SRTP MUST therefore carefully consider the risk of using this padding without proper integrity protection.
特定のパディングタイプが整合性のない状態で使用されている場合、いくつかのパディングが必要な操作の暗号モード、例えば、標準の暗号ブロック連鎖(CBC)は、機密性への攻撃に非常に敏感です。攻撃[用 V02]は CBC モードと一緒に使用した場合、図 1 を参照して説明したように、これは、標準の RTP パディングのためのケースが実際にあることを示しています。その後したがって、慎重に適切な完全性保護なしでこの詰め物を使用することの危険性を考慮しなければならない SRTP への追加を変換します。

## 9.5.2 。暗黙ヘッダー認証 (9.5.2. Implicit Header Authentication)

The IV formation of the f8-mode gives implicit authentication (IHA) of the RTP header, even when message authentication is not used. When IHA is used, an attacker that modifies the value of the RTP header will cause the decryption process at the receiver to produce random plaintext values. While this protection is not equivalent to message authentication, it may be useful for some applications.
F8 モードの IV 形成は、メッセージ認証を使用しない場合でも、 RTP ヘッダの暗黙の認証(IHA)を与えます。 IHA が使用される場合、 RTP ヘッダの値を変更する攻撃者は、ランダム平文値を生成するために受信機において復号処理が発生します。この保護は、メッセージ認証と同等ではありませんが、それはいくつかの用途のために有用である可能性があります。

## 10 前方誤り訂正メカニズムと 10 の相互作用 (10. Interaction with Forward Error Correction mechanisms)

The default processing when using Forward Error Correction (e.g., RFC 2733) processing with SRTP SHALL be to perform FEC processing prior to SRTP processing on the sender side and to perform SRTP processing prior to FEC processing on the receiver side. Any change to this ordering (reversing it, or, placing FEC between SRTP encryption and SRTP authentication) SHALL be signaled out of band.
前方誤り訂正を使用する場合、デフォルトの処理(例えばは、 RFC 2733)SRTP による処理は、送信側の前 SRTP 処理に FEC 処理を実行し、受信側で前 FEC 処理 SRTP 処理を実行すること SHALL 。この順序(それを逆転させる、または、 SRTP 暗号化と SRTP 認証の間で FEC を置く)への変更は、帯域外で合図するものとします。

## 11.シナリオ (11. Scenarios)

SRTP can be used as security protocol for the RTP/RTCP traffic in many different scenarios. SRTP has a number of configuration options, in particular regarding key usage, and can have impact on the total performance of the application according to the way it is used. Hence, the use of SRTP is dependent on the kind of scenario and application it is used with. In the following, we briefly illustrate some use cases for SRTP, and give some guidelines for recommended setting of its options.
SRTP は、多くの異なるシナリオに RTP / RTCP トラフィックのセキュリティプロトコルとして使用することができます。 SRTP キー使用に関する特定の設定オプションの数を有し、それが使用されている方法に従って、アプリケーション全体の性能に影響を与えることができます。したがって、 SRTP を使用するシナリオと、それが一緒に使用されているアプリケーションの種類に依存しています。以下では、我々は簡単に SRTP のためのいくつかのユースケースを示しており、そのオプションの推奨設定のためのいくつかのガイドラインを与えます。

## 11.1 。ユニキャスト (11.1. Unicast)

A typical example would be a voice call or video-on-demand application.
典型的な例は、音声通話やビデオオンデマンドのアプリケーションになります。

Consider one bi-directional RTP stream, as one RTP session. It is possible for the two parties to share the same master key in the two directions according to the principles of Section 9.1. The first round of the key derivation splits the master key into any or all of the following session keys (according to the provided security functions):
1 つの RTP セッションとして、 1 双方向 RTP ストリームを考えてみましょう。両当事者は、 9.1 節の原則に従って双方向で同じマスターキーを共有することが可能です。鍵導出の最初のラウンドは(提供されるセキュリティ機能に応じて)次のセッションキーのいずれかまたは全てにマスター鍵を分割します:

SRTP_encr_key, SRTP_auth_key, SRTCP_encr_key, and SRTCP_auth key.
(For simplicity, we omit discussion of the salts, which are also derived.) In this scenario, it will in most cases suffice to have a single master key with the default lifetime. This guarantees sufficiently long lifetime of the keys and a minimum set of keys in place for most practical purposes. Also, in this case RTCP protection can be applied smoothly. Under these assumptions, use of the MKI can be omitted. As the key-derivation in combination with large difference in the packet rate in the respective directions may require simultaneous storage of several session keys, if storage is an issue, we recommended to use low-rate key derivation.
(簡単にするために、我々はまた、導出されている塩、の議論を省略します。)このシナリオでは、それはほとんどの場合、デフォルトの寿命を持つ単一のマスターキーを持ってすればよいです。これは、キーの十分に長い寿命と最も実用的な目的のための場所にあるキーの最小セットを保証します。また、この場合には RTCP 保護がスムーズに適用することができます。これらの仮定の下では、 MKI の使用は省略することができます。ストレージが問題になる場合は各方向のパケット率に大きな差との組み合わせでキー導出は、いくつかのセッションキーの同時保存が必要な場合がありますように、我々は、低レート鍵の導出を使用することをお勧めします。

The same considerations can be extended to the unicast scenario with multiple RTP sessions, where each session would have a distinct master key.
同様の考察は、各セッションは別個のマスタ鍵を有することになる複数の RTP セッションとユニキャストシナリオに拡張することができます。

## 11.2 。マルチキャスト(1 つの送信者) (11.2. Multicast (one sender))

Just as with (unprotected) RTP, a scalability issue arises in big groups due to the possibly very large amount of SRTCP Receiver Reports that the sender might need to process. In SRTP, the sender may have to keep state (the cryptographic context) for each receiver, or more precisely, for the SRTCP used to protect Receiver Reports. The overhead increases proportionally to the size of the group. In particular, re-keying requires special concern, see below.
ただ、(保護されていない)RTP と同様に、スケーラビリティの問題が SRTCP レシーバーの可能性が非常に大量に起因する大きなグループに発生する送信者が処理する必要があるかもしれないことを報告します。 SRTP では、送信者が受信者レポートを保護するために使用 SRTCP のために、より正確に各受信機のための状態(暗号の文脈)を維持、またはする必要があります。オーバーヘッドは、グループのサイズに比例して増加します。具体的には、再キーイングは、特別な関心を必要とし、以下を参照してください。

Consider first a small group of receivers. There are a few possible setups with the distribution of master keys among the receivers. Given a single RTP session, one possibility is that the receivers share the same master key as per Section 9.1 to secure all their respective RTCP traffic. This shared master key could then be the same one used by the sender to protect its outbound SRTP traffic. Alternatively, it could be a master key shared only among the receivers and used solely for their SRTCP traffic. Both alternatives require the receivers to trust each other.
最初の受信者の小グループを考えてみましょう。受信機の間でマスターキーの分布を持ついくつかの可能なセットアップがあります。単一の RTP セッションを考えると、 1 つの可能性は、受信機がすべて、それぞれの RTCP トラフィックを保護するために、セクション 9.1 あたりと同じマスターキーを共有することです。この共有マスターキーは、そのアウトバウンド SRTP トラフィックを保護するために、送信者が使用するものと同じである可能性があります。また、それだけで受信機の間で共有し、彼らの SRTCP トラフィックのためだけに使用されるマスターキーである可能性があります。両方の選択肢は、お互いを信頼するように受信機を必要としています。

Considering SRTCP and key storage, it is recommended to use low-rate (or zero) keyderivation (except the mandatory initial one), so that the sender does not need to store too many session keys (each SRTCP stream might otherwise have a different session key at a given point in time, as the SRTCP sources send at different times). Thus, in case key derivation is wanted for SRTP, the cryptographic context for SRTP can be kept separate from the SRTCP crypto context, so that it is possible to have a keyderivation_rate of 0 for SRTCP and a non- zero value for SRTP.
SRTCP と鍵保管を考えると、低レート(またはゼロ)を使用することが推奨されているキー(1 つの必須初期を除く)の導出、送信者があまりにも多くのセッションキーを格納する必要がないように、(各 SRTCP ストリームそうでない場合は異なる場合があります特定の時点でのセッション鍵、 SRTCP ソースが異なる時間に送信されるように)。鍵有することが可能であるようにこのように、鍵導出が SRTP のために望まれる場合には、 SRTP 用の暗号コンテキストは、 SRTCP 暗号コンテキストとは別に維持することができる SRTCP 0 の derivation_rate および SRTP のために非ゼロ値を。

Use of the MKI for re-keying is RECOMMENDED for most applications (see Section 8.1).
再入力のための MKI の使用は、ほとんどのアプリケーション(8.1 節を参照)をお勧めします。

If there are more than one SRTP/SRTCP stream (within the same RTP session) that share the master key, the upper limit of 2^48 SRTP packets / 2^31 SRTCP packets means that, before one of the streams reaches its maximum number of packets, re-keying MUST be triggered on ALL streams sharing the master key. (From strict security point of view, only the stream reaching the maximum would need to be re-keyed, but then the streams would no longer be sharing master key, which is the intention.) A local policy at the sender side should force rekeying in a way that the maximum packet limit is not reached on any of the streams. Use of the MKI for re-keying is RECOMMENDED.
マスター鍵を共有する複数の SRTP /(同じ RTP セッション内)SRTCP ストリームがある場合、 2 ^ 48 の SRTP パケットの上限/ 2 ^ 31 個の SRTCP パケットがストリームのうちの 1 つがその最大数に達する前に、ということを意味しますパケットの再キーイングは、マスターキーを共有するすべてのストリームでトリガされなければなりません。(ビューの厳格なセキュリティの観点から、最大に達するだけストリームを再キーイングする必要があるが、その後の流れはもはや意図されたマスター鍵を共有することがないだろう。)ローカルポリシーを送信側でリキーを強制すべきですように最大パケット限界は、ストリームのいずれにも到達していないこと。再入力のための MKI の使用が推奨されます。

In large multicast with one sender, the same considerations as for the small group multicast hold. The biggest issue in this scenario is the additional load placed at the sender side, due to the state (cryptographic contexts) that has to be maintained for each receiver, sending back RTCP Receiver Reports. At minimum, a replay window might need to be maintained for each RTCP source.
1 人の送信者と大マルチキャストに、小グループマルチキャストホールドと同じ考慮事項。このシナリオにおける最大の問題は、 RTCP 受信レポートを送り返す、各受信機のために維持されなければならない状態に起因する送信側に配置された追加の負荷、(暗号コンテキスト)です。最低でも、リプレイウィンドウは、各 RTCP ソースのために維持する必要がある場合があります。

## 11.3 。再キーイングおよびアクセス制御 (11.3. Re-keying and access control)

Re-keying may occur due to access control (e.g., when a member is removed during a multicast RTP session), or for pure cryptographic reasons (e.g., the key is at the end of its lifetime). When using SRTP default transforms, the master key MUST be replaced before any of the index spaces are exhausted for any of the streams protected by one and the same master key.
再キーイングにより(例えば、部材はマルチキャスト RTP セッション中に除去される場合)、または純粋な暗号化の理由(例えば、キーは、その寿命の終わりにある)のためのアクセス制御に起こり得ます。 SRTP のデフォルトの変換を使用すると索引スペースのいずれかが 1 と同じマスターキーによって保護されたストリームのいずれかのために排出される前に、マスターキーを交換する必要があります。

How key management re-keys SRTP implementations is out of scope, but it is clear that there are straightforward ways to manage keys for a multicast group. In one-sender multicast, for example, it is typically the responsibility of the sender to determine when a new key is needed. The sender is the one entity that can keep track of when the maximum number of packets has been sent, as receivers may join and leave the session at any time, there may be packet loss and delay etc. In scenarios other than one-sender multicast, other methods can be used. Here, one must take into consideration that key exchange can be a costly operation, taking several seconds for a single exchange. Hence, some time before the master key is exhausted/expires, out-of-band key management is initiated, resulting in a new master key that is shared with the receiver(s). In any event, to maintain synchronization when switching to the new key, group policy might choose between using the MKI and the <From, To>, as described in Section 8.1.
どのように鍵管理の再キーの SRTP 実装することは適用範囲外であるが、マルチキャストグループの鍵を管理するための簡単な方法があることは明らかです。一送信者のマルチキャストでは、例えば、一般的に、新しいキーが必要な場合を決定するために、送信者の責任です。受信機は、一送信者マルチキャスト以外のシナリオでなど参加し、いつでもセッションを残し、パケット損失があってもよいし、遅らせることができるように送信側は、パケットの最大数が送信されたときを追跡することができるものエンティティであります、他の方法を用いることができます。ここで、 1 は、鍵交換は、単一の交換のために数秒を取って、コストのかかる操作できることを考慮に入れなければなりません。マスターキーの有効期限が切れる/排出される前に、したがって、いくつかの時間は、アウトオブバンドの鍵管理は、受信機(単数または複数)と共有される新たなマスターキー、その結果、開始されます。

For access control purposes, the <From, To> periods are set at the desired granularity, dependent on the packet rate. High rate re- keying can be problematic for SRTCP in some large-group scenarios. As mentioned, there are potential problems in using the SRTP index, rather than the SRTCP index, for determining the master key. In particular, for short periods during switching of master keys, it may be the case that SRTCP packets are not under the current master key of the correspondent SRTP. Therefore, using the MKI for re-keying in such scenarios will produce better results.
アクセス制御の目的のために、<へ、から>期間がパケットレートに依存して、所望の粒度に設定されています。高速再キーイングは、いくつかの大規模なグループのシナリオで SRTCP のために問題がある可能性があります。上述したように、マスター鍵を決定するため、 SRTP インデックスではなく、 SRTCP インデックスを使用する際の潜在的な問題があります。具体的には、マスターキーの切り替え時の短い期間のために、それは、 SRTCP パケットがコレス SRTP の現在のマスターキーではないこと場合であってもよいです。したがって、そのようなシナリオでは、再キーイングのための MKI を使用すると、より良い結果をもたらすであろう。

## 11.4 。基本的なシナリオの概要 (11.4. Summary of basic scenarios)

The description of these scenarios highlights some recommendations on the use of SRTP, mainly related to re-keying and large scale multicast:
:これらのシナリオの記述は、主に再キーイングや大規模なマルチキャストに関連し、 SRTP の使用に関するいくつかの勧告を強調します

Do not use fast re-keying with the <From, To> feature. It may, in particular, give problems in retrieving the correct SRTCP key, if an SRTCP packet arrives close to the re-keying time. The MKI SHOULD be used in this case.
高速再キーイング<へ、から>機能では使用しないでください。 SRTCP パケットが再キーイング時間に近い到着した場合は、特に、正しい SRTCP キーを取得する際に問題を与える可能性があります。 MKI は、この場合には、使用されてください。

If multiple SRTP streams in the same RTP session share the same master key, also moderate rate re-keying MAY have the same problems, and the MKI SHOULD be used.
同じ RTP セッションのシェアで複数の SRTP ストリームが同じマスターキーは、また、適度なレートの再入力は同じ問題を抱えているかもしれない、と MKI を使用する必要がある場合。

Though offering increased security, a non-zero keyderivationrate is NOT RECOMMENDED when trying to minimize the number of keys in use with multiple streams.
強化されたセキュリティを提供していますが、非ゼロの鍵導出複数のストリームで使用中のキーの数を最小限にしようとしたときに料金はお勧めしません。

## 12. IANA の考慮事項 (12. IANA Considerations)

The RTP specification establishes a registry of profile names for use by higher-level control protocols, such as the Session Description Protocol (SDP), to refer to transport methods. This profile registers the name "RTP/SAVP".
RTP 仕様は、方法を輸送するために参照するために、そのようなセッション記述プロトコル(SDP)のような、より高いレベルの制御プロトコルによって使用するためのプロファイル名のレジストリを確立します。このプロファイルは、名前「RTP / SAVP」を登録します。

SRTP uses cryptographic transforms which a key management protocol signals. It is the task of each particular key management protocol to register the cryptographic transforms or suites of transforms with IANA. The key management protocol conveys these protocol numbers, not SRTP, and each key management protocol chooses the numbering scheme and syntax that it requires.
SRTP は、鍵管理プロトコル信号暗号変換を使用します。これは、 IANA との変換の暗号変換またはスイートを登録するには、各特定のキー管理プロトコルの課題です。鍵管理プロトコルは、これらのプロトコル番号ではなく、 SRTP を搬送し、各キー管理プロトコルは、それが必要とナンバリングスキームと構文を選択します。

Specification of a key management protocol for SRTP is out of scope here. Section 8.2, however, provides guidance on the parameters that need to be defined for the default and mandatory transforms.
SRTP 用の鍵管理プロトコルの仕様は、ここでは範囲外です。 8.2 節では、しかし、デフォルトと必須の変換のために定義する必要があるパラメータに関するガイダンスを提供します。

## 13.謝辞 (13. Acknowledgements)

David Oran (Cisco) and Rolf Blom (Ericsson) are co-authors of this document but their valuable contributions are acknowledged here to keep the length of the author list down.
デヴィッドオラン(シスコ)とロルフブロム(エリクソン)は、本書の共著者ですが、彼らの貴重な貢献をダウン著者リストの長さを保つためにここに認めています。

The authors would in addition like to thank Magnus Westerlund, Brian Weis, Ghyslain Pelletier, Morgan Lindqvist, Robert Fairlie- Cuninghame, Adrian Perrig, the AVT WG and in particular the chairmen Colin Perkins and Stephen Casner, the Transport and Security Area Directors, and Eric Rescorla for their reviews and support.
著者は、ほかにマグヌスウェスター、ブライアン・ワイス、ギレイン・ペルティエ、モーガン・リンドクビスト、ロバート Fairlie- Cuninghame 、エイドリアン・ペリッグ、 AVT WG 特に議長コリンパーキンスとステファン・キャスナー、トランスポートおよびセキュリティエリアディレクターに感謝したいと思います、と彼らのレビューと支援のためのエリックレスコラ。

## 14.参考文献 (14. References)

## 14.1 。引用規格 (14.1. Normative References)

[AES] NIST, "Advanced Encryption Standard (AES)", FIPS PUB 197, http://www.nist.gov/aes/
[AES] NIST 、 "高度暗号化標準(AES)"、 FIPS パブ 197 、 http://www.nist.gov/aes/

[RFC2104] Krawczyk, H., Bellare, M. and R. Canetti, "HMAC: Keyed- Hashing for Message Authentication", RFC 2104, February 1997.
[RFC2104] Krawczyk 、 H.、ベラー、 M 。および R.カネッティ、 "HMAC:メッセージ認証のための Keyed-ハッシュ"、 RFC 2104 、 1997 年 2 月。

[RFC2119] Bradner, S., "Key words for use in RFCs to Indicate Requirement Levels", BCP 14, RFC 2119, March 1997.
[RFC2119]ブラドナーの、 S.、 "要件レベルを示すために RFCs における使用のためのキーワード"、 BCP 14 、 RFC 2119 、 1997 年 3 月。

[RFC2401] Kent, S. and R. Atkinson, "Security Architecture for Internet Protocol", RFC 2401, November 1998.
[RFC2401]ケント、 S.と R.アトキンソン、 "インターネットプロトコルのためのセキュリティー体系"、 RFC 2401 、 1998 年 11 月。

[RFC2828] Shirey, R., "Internet Security Glossary", FYI 36, RFC 2828, May 2000.
[RFC2828] Shirey, R., "Internet Security Glossary", FYI 36, RFC 2828, May 2000.

[RFC3550] Schulzrinne, H., Casner, S., Frederick, R. and V. Jacobson, "RTP: A Transport Protocol for Real-time Applications", RFC 3550, July 2003.
[RFC3550] Schulzrinne, H., Casner, S., Frederick, R. and V. Jacobson, "RTP: A Transport Protocol for Real-time Applications", RFC 3550, July 2003.

[RFC3551] Schulzrinne, H. and S. Casner, "RTP Profile for Audio and Video Conferences with Minimal Control", RFC 3551, July 2003.
[RFC3551] Schulzrinne, H. and S. Casner, "RTP Profile for Audio and Video Conferences with Minimal Control", RFC 3551, July 2003.

## 14.2. Informative References (14.2. Informative References)

[AES-CTR] Lipmaa, H., Rogaway, P. and D. Wagner, "CTR-Mode Encryption", NIST, http://csrc.nist.gov/encryption/modes/ workshop1/papers/lipmaa-ctr.pdf
[AES-CTR] Lipmaa, H., Rogaway, P. and D. Wagner, "CTR-Mode Encryption", NIST, http://csrc.nist.gov/encryption/modes/ workshop1/papers/lipmaa-ctr.pdf

[B96] Bellovin, S., "Problem Areas for the IP Security Protocols," in Proceedings of the Sixth Usenix Unix Security Symposium, pp. 1-16, San Jose, CA, July 1996 (http://www.research.att.com/~smb/papers/index.html).
[B96] Bellovin, S., "Problem Areas for the IP Security Protocols," in Proceedings of the Sixth Usenix Unix Security Symposium, pp. 1-16, San Jose, CA, July 1996 (http://www.research.att.com/~smb/papers/index.html).

[BDJR] Bellare, M., Desai, A., Jokipii, E. and P. Rogaway, "A Concrete Treatment of Symmetric Encryption: Analysis of DES Modes of Operation", Proceedings 38th IEEE FOCS, pp. 394- 403, 1997.
[BDJR] Bellare, M., Desai, A., Jokipii, E. and P. Rogaway, "A Concrete Treatment of Symmetric Encryption: Analysis of DES Modes of Operation", Proceedings 38th IEEE FOCS, pp. 394- 403, 1997.

[BS00] Biryukov, A. and A. Shamir, "Cryptanalytic Time/Memory/Data Tradeoffs for Stream Ciphers", Proceedings, ASIACRYPT 2000, LNCS 1976, pp. 1-13, Springer Verlag.
[BS00] Biryukov, A. and A. Shamir, "Cryptanalytic Time/Memory/Data Tradeoffs for Stream Ciphers", Proceedings, ASIACRYPT 2000, LNCS 1976, pp. 1-13, Springer Verlag.

[C99] Crowell, W. P., "Introduction to the VENONA Project", http://www.nsa.gov:8080/docs/venona/index.html.
[C99] Crowell, W. P., "Introduction to the VENONA Project", http://www.nsa.gov:8080/docs/venona/index.html.

[CTR] Dworkin, M., NIST Special Publication 800-38A, "Recommendation for Block Cipher Modes of Operation: Methods and Techniques", 2001. http://csrc.nist.gov/publications/nistpubs/800-38a/sp800- 38a.pdf.
[CTR] Dworkin, M., NIST Special Publication 800-38A, "Recommendation for Block Cipher Modes of Operation: Methods and Techniques", 2001. http://csrc.nist.gov/publications/nistpubs/800-38a/sp800- 38a.pdf.

[f8-a] 3GPP TS 35.201 V4.1.0 (2001-12) Technical Specification 3rd Generation Partnership Project; Technical Specification Group Services and System Aspects; 3G Security; Specification of the 3GPP Confidentiality and Integrity Algorithms; Document 1: f8 and f9 Specification (Release 4).
[f8-a] 3GPP TS 35.201 V4.1.0 (2001-12) Technical Specification 3rd Generation Partnership Project; Technical Specification Group Services and System Aspects; 3G Security; Specification of the 3GPP Confidentiality and Integrity Algorithms; Document 1: f8 and f9 Specification (Release 4).

[f8-b] 3GPP TR 33.908 V4.0.0 (2001-09) Technical Report 3rd Generation Partnership Project; Technical Specification Group Services and System Aspects; 3G Security; General Report on the Design, Specification and Evaluation of 3GPP Standard Confidentiality and Integrity Algorithms (Release 4).
[f8-b] 3GPP TR 33.908 V4.0.0 (2001-09) Technical Report 3rd Generation Partnership Project; Technical Specification Group Services and System Aspects; 3G Security; General Report on the Design, Specification and Evaluation of 3GPP Standard Confidentiality and Integrity Algorithms (Release 4).

[GDOI] Baugher, M., Weis, B., Hardjono, T. and H. Harney, "The Group Domain of Interpretation, RFC 3547, July 2003.
[GDOI] Baugher, M., Weis, B., Hardjono, T. and H. Harney, "The Group Domain of Interpretation, RFC 3547, July 2003.

[HAC] Menezes, A., Van Oorschot, P. and S. Vanstone, "Handbook of Applied Cryptography", CRC Press, 1997, ISBN 0-8493- 8523-7.
[HAC] Menezes, A., Van Oorschot, P. and S. Vanstone, "Handbook of Applied Cryptography", CRC Press, 1997, ISBN 0-8493- 8523-7.

[H80] Hellman, M. E., "A cryptanalytic time-memory trade-off", IEEE Transactions on Information Theory, July 1980, pp. 401-406.
[H80] Hellman, M. E., "A cryptanalytic time-memory trade-off", IEEE Transactions on Information Theory, July 1980, pp. 401-406.

[IK] T. Iwata and T. Kohno: "New Security Proofs for the 3GPP Confidentiality and Integrity Algorithms", Proceedings of FSE 2004.
[IK] T. Iwata and T. Kohno: "New Security Proofs for the 3GPP Confidentiality and Integrity Algorithms", Proceedings of FSE 2004.

[KINK] Thomas, M. and J. Vilhuber, "Kerberized Internet Negotiation of Keys (KINK)", Work in Progress.
[KINK] Thomas, M. and J. Vilhuber, "Kerberized Internet Negotiation of Keys (KINK)", Work in Progress.

[KEYMGT] Arrko, J., et al., "Key Management Extensions for Session Description Protocol (SDP) and Real Time Streaming Protocol (RTSP)", Work in Progress.
[KEYMGT] Arrko, J., et al., "Key Management Extensions for Session Description Protocol (SDP) and Real Time Streaming Protocol (RTSP)", Work in Progress.

[KSYH] Kang, J-S., Shin, S-U., Hong, D. and O. Yi, "Provable Security of KASUMI and 3GPP Encryption Mode f8", Proceedings Asiacrypt 2001, Springer Verlag LNCS 2248, pp. 255-271, 2001.
[KSYH] Kang, J-S., Shin, S-U., Hong, D. and O. Yi, "Provable Security of KASUMI and 3GPP Encryption Mode f8", Proceedings Asiacrypt 2001, Springer Verlag LNCS 2248, pp. 255-271, 2001.

[MIKEY] Arrko, J., et. al., "MIKEY: Multimedia Internet KEYing", Work in Progress.
[MIKEY] Arrko, J., et. al., "MIKEY: Multimedia Internet KEYing", Work in Progress.

[MF00] McGrew, D. and S. Fluhrer, "Attacks on Encryption of Redundant Plaintext and Implications on Internet Security", the Proceedings of the Seventh Annual Workshop on Selected Areas in Cryptography (SAC 2000), Springer-Verlag.
[MF00] McGrew, D. and S. Fluhrer, "Attacks on Encryption of Redundant Plaintext and Implications on Internet Security", the Proceedings of the Seventh Annual Workshop on Selected Areas in Cryptography (SAC 2000), Springer-Verlag.

[PCST1] Perrig, A., Canetti, R., Tygar, D. and D. Song, "Efficient and Secure Source Authentication for Multicast", in Proc. of Network and Distributed System Security Symposium NDSS 2001, pp. 35-46, 2001.
[PCST1] Perrig, A., Canetti, R., Tygar, D. and D. Song, "Efficient and Secure Source Authentication for Multicast", in Proc. of Network and Distributed System Security Symposium NDSS 2001, pp. 35-46, 2001.

[PCST2] Perrig, A., Canetti, R., Tygar, D. and D. Song, "Efficient Authentication and Signing of Multicast Streams over Lossy Channels", in Proc. of IEEE Security and Privacy Symposium S&P2000, pp. 56-73, 2000.
[PCST2] Perrig, A., Canetti, R., Tygar, D. and D. Song, "Efficient Authentication and Signing of Multicast Streams over Lossy Channels", in Proc. of IEEE Security and Privacy Symposium S&P2000, pp. 56-73, 2000.

[RFC1750] Eastlake, D., Crocker, S. and J. Schiller, "Randomness Recommendations for Security", RFC 1750, December 1994.
[RFC1750] Eastlake, D., Crocker, S. and J. Schiller, "Randomness Recommendations for Security", RFC 1750, December 1994.

[RFC2675] Borman, D., Deering, S. and R. Hinden, "IPv6 Jumbograms", RFC 2675, August 1999.
[RFC2675] Borman, D., Deering, S. and R. Hinden, "IPv6 Jumbograms", RFC 2675, August 1999.

[RFC3095] Bormann, C., Burmeister, C., Degermark, M., Fukuhsima, H., Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke, T., Yoshimura, T. and H. Zheng, "RObust Header Compression: Framework and Four Profiles: RTP, UDP, ESP, and uncompressed (ROHC)", RFC 3095, July 2001.
[RFC3095] Bormann, C., Burmeister, C., Degermark, M., Fukuhsima, H., Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke, T., Yoshimura, T. and H. Zheng, "RObust Header Compression: Framework and Four Profiles: RTP, UDP, ESP, and uncompressed (ROHC)", RFC 3095, July 2001.

[RFC3242] Jonsson, L-E. and G. Pelletier, "RObust Header Compression (ROHC): A Link-Layer Assisted Profile for IP/UDP/RTP ", RFC 3242, April 2002.
[RFC3242] Jonsson, L-E. and G. Pelletier, "RObust Header Compression (ROHC): A Link-Layer Assisted Profile for IP/UDP/RTP ", RFC 3242, April 2002.

[SDMS] Andreasen, F., Baugher, M. and D. Wing, "Session Description Protocol Security Descriptions for Media Streams", Work in Progress.
[SDMS] Andreasen, F., Baugher, M. and D. Wing, "Session Description Protocol Security Descriptions for Media Streams", Work in Progress.

[SWO] Svanbro, K., Wiorek, J. and B. Olin, "Voice-over-IP-over- wireless", Proc. PIMRC 2000, London, Sept. 2000.
[SWO] Svanbro, K., Wiorek, J. and B. Olin, "Voice-over-IP-over- wireless", Proc. PIMRC 2000, London, Sept. 2000.

[V02] Vaudenay, S., "Security Flaws Induced by CBC Padding - Application to SSL, IPsec, WTLS...", Advances in Cryptology, EUROCRYPT'02, LNCS 2332, pp. 534-545.
[V02] Vaudenay, S., "Security Flaws Induced by CBC Padding - Application to SSL, IPsec, WTLS...", Advances in Cryptology, EUROCRYPT'02, LNCS 2332, pp. 534-545.

[WC81] Wegman, M. N., and J.L. Carter, "New Hash Functions and Their Use in Authentication and Set Equality", JCSS 22, 265-279, 1981.
[WC81] Wegman, M. N., and J.L. Carter, "New Hash Functions and Their Use in Authentication and Set Equality", JCSS 22, 265-279, 1981.

## Appendix A: Pseudocode for Index Determination (Appendix A: Pseudocode for Index Determination)

The following is an example of pseudo-code for the algorithm to determine the index i of an SRTP packet with sequence number SEQ. In the following, signed arithmetic is assumed.
The following is an example of pseudo-code for the algorithm to determine the index i of an SRTP packet with sequence number SEQ. In the following, signed arithmetic is assumed.

```
if (s_l < 32,768)
   if (SEQ - s_l > 32,768)
      set v to (ROC-1) mod 2^32
   else
      set v to ROC
   endif
else
   if (s_l - 32,768 > SEQ)
      set v to (ROC+1) mod 2^32
   else
      set v to ROC
   endif
endif
return SEQ + v*65,536
```

## Appendix B: Test Vectors (Appendix B: Test Vectors)

All values are in hexadecimal.
All values are in hexadecimal.

### B.1. AES-f8 Test Vectors (B.1. AES-f8 Test Vectors)

```
SRTP PREFIX LENGTH  :   0

RTP packet header   :   806e5cba50681de55c621599

RTP packet payload  :   70736575646f72616e646f6d6e657373
                        20697320746865206e65787420626573
                        74207468696e67

ROC                 :   d462564a
key                 :   234829008467be186c3de14aae72d62c
salt key            :   32f2870d
key-mask (m)        :   32f2870d555555555555555555555555
key XOR key-mask    :   11baae0dd132eb4d3968b41ffb278379

IV                  :   006e5cba50681de55c621599d462564a
IV'                 :   595b699bbd3bc0df26062093c1ad8f73

j = 0
IV' xor j           :   595b699bbd3bc0df26062093c1ad8f73
S(-1)               :   00000000000000000000000000000000
IV' xor S(-1) xor j :   595b699bbd3bc0df26062093c1ad8f73
S(0)                :   71ef82d70a172660240709c7fbb19d8e
plaintext           :   70736575646f72616e646f6d6e657373
ciphertext          :   019ce7a26e7854014a6366aa95d4eefd

j = 1
IV' xor j           :   595b699bbd3bc0df26062093c1ad8f72
S(0)                :   71ef82d70a172660240709c7fbb19d8e
IV' xor S(0) xor j  :   28b4eb4cb72ce6bf020129543a1c12fc
S(1)                :   3abd640a60919fd43bd289a09649b5fc
plaintext           :   20697320746865206e65787420626573
ciphertext          :   1ad4172a14f9faf455b7f1d4b62bd08f

j = 2
IV' xor j           :   595b699bbd3bc0df26062093c1ad8f71
S(1)                :   3abd640a60919fd43bd289a09649b5fc
IV' xor S(1) xor j  :   63e60d91ddaa5f0b1dd4a93357e43a8d
S(2)                :   220c7a8715266565b09ecc8a2a62b11b
plaintext           :   74207468696e67
ciphertext          :   562c0eef7c4802
```

### B.2. AES-CM Test Vectors (B.2. AES-CM Test Vectors)

```
Keystream segment length: 1044512 octets (65282 AES blocks)
Session Key:      2B7E151628AED2A6ABF7158809CF4F3C
Rollover Counter: 00000000
Sequence Number:  0000
SSRC:             00000000
Session Salt:     F0F1F2F3F4F5F6F7F8F9FAFBFCFD0000 (already shifted)
Offset:           F0F1F2F3F4F5F6F7F8F9FAFBFCFD0000

Counter                            Keystream

F0F1F2F3F4F5F6F7F8F9FAFBFCFD0000   E03EAD0935C95E80E166B16DD92B4EB4
F0F1F2F3F4F5F6F7F8F9FAFBFCFD0001   D23513162B02D0F72A43A2FE4A5F97AB
F0F1F2F3F4F5F6F7F8F9FAFBFCFD0002   41E95B3BB0A2E8DD477901E4FCA894C0
...                                ...
F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF   EC8CDF7398607CB0F2D21675EA9EA1E4
F0F1F2F3F4F5F6F7F8F9FAFBFCFDFF00   362B7C3C6773516318A077D7FC5073AE
F0F1F2F3F4F5F6F7F8F9FAFBFCFDFF01   6A2CC3787889374FBEB4C81B17BA6C44
Nota Bene: this test case is contrived so that the latter part of the keystream segment coincides with the test case in Section F.5.1 of [CTR].
Nota Bene: this test case is contrived so that the latter part of the keystream segment coincides with the test case in Section F.5.1 of [CTR].
```

### B.3. Key Derivation Test Vectors (B.3. Key Derivation Test Vectors)

This section provides test data for the default key derivation function, which uses AES-128 in Counter Mode. In the following, we walk through the initial key derivation for the AES-128 Counter Mode cipher, which requires a 16 octet session encryption key and a 14 octet session salt, and an authentication function which requires a 94-octet session authentication key. These values are called the cipher key, the cipher salt, and the auth key in the following. Since this is the initial key derivation and the key derivation rate is equal to zero, the value of (index DIV keyderivationrate) is zero (actually, a six-octet string of zeros). In the following, we shorten keyderivationrate to kdr.
This section provides test data for the default key derivation function, which uses AES-128 in Counter Mode. In the following, we walk through the initial key derivation for the AES-128 Counter Mode cipher, which requires a 16 octet session encryption key and a 14 octet session salt, and an authentication function which requires a 94-octet session authentication key. These values are called the cipher key, the cipher salt, and the auth key in the following. Since this is the initial key derivation and the key derivation rate is equal to zero, the value of (index DIV keyderivationrate) is zero (actually, a six-octet string of zeros). In the following, we shorten keyderivationrate to kdr.

The inputs to the key derivation function are the 16 octet master key and the 14 octet master salt:
The inputs to the key derivation function are the 16 octet master key and the 14 octet master salt:

```
master key:  E1F97A0D3E018BE0D64FA32C06DE4139
master salt: 0EC675AD498AFEEBB6960B3AABE6
```

We first show how the cipher key is generated. The input block for AES-CM is generated by exclusive-oring the master salt with the concatenation of the encryption key label 0x00 with (index DIV kdr), then padding on the right with two null octets (which implements the multiply-by-2^16 operation, see Section 4.3.3). The resulting value is then AES-CM- encrypted using the master key to get the cipher key.
We first show how the cipher key is generated. The input block for AES-CM is generated by exclusive-oring the master salt with the concatenation of the encryption key label 0x00 with (index DIV kdr), then padding on the right with two null octets (which implements the multiply-by-2^16 operation, see Section 4.3.3). The resulting value is then AES-CM- encrypted using the master key to get the cipher key.

```
index DIV kdr:                 000000000000
label:                       00
master salt:   0EC675AD498AFEEBB6960B3AABE6
-----------------------------------------------
xor:           0EC675AD498AFEEBB6960B3AABE6     (x, PRF input)

x*2^16:        0EC675AD498AFEEBB6960B3AABE60000 (AES-CM input)

cipher key:    C61E7A93744F39EE10734AFE3FF7A087 (AES-CM output)
```

Next, we show how the cipher salt is generated. The input block for AES-CM is generated by exclusive-oring the master salt with the concatenation of the encryption salt label. That value is padded and encrypted as above.
Next, we show how the cipher salt is generated. The input block for AES-CM is generated by exclusive-oring the master salt with the concatenation of the encryption salt label. That value is padded and encrypted as above.

```
index DIV kdr:                 000000000000
label:                       02
master salt:   0EC675AD498AFEEBB6960B3AABE6

----------------------------------------------
xor:           0EC675AD498AFEE9B6960B3AABE6     (x, PRF input)

x*2^16:        0EC675AD498AFEE9B6960B3AABE60000 (AES-CM input)

30CBBC08863D8C85D49DB34A9AE17AC6 (AES-CM ouptut)

cipher salt:   30CBBC08863D8C85D49DB34A9AE1
```

We now show how the auth key is generated. The input block for AES- CM is generated as above, but using the authentication key label.
We now show how the auth key is generated. The input block for AES- CM is generated as above, but using the authentication key label.

```
index DIV kdr:                   000000000000
label:                         01
master salt:     0EC675AD498AFEEBB6960B3AABE6
-----------------------------------------------
xor:             0EC675AD498AFEEAB6960B3AABE6     (x, PRF input)

x*2^16:          0EC675AD498AFEEAB6960B3AABE60000 (AES-CM input)
```

Below, the auth key is shown on the left, while the corresponding AES input blocks are shown on the right.
Below, the auth key is shown on the left, while the corresponding AES input blocks are shown on the right.

```
auth key                           AES input blocks
CEBE321F6FF7716B6FD4AB49AF256A15   0EC675AD498AFEEAB6960B3AABE60000
6D38BAA48F0A0ACF3C34E2359E6CDBCE   0EC675AD498AFEEAB6960B3AABE60001
E049646C43D9327AD175578EF7227098   0EC675AD498AFEEAB6960B3AABE60002
6371C10C9A369AC2F94A8C5FBCDDDC25   0EC675AD498AFEEAB6960B3AABE60003
6D6E919A48B610EF17C2041E47403576   0EC675AD498AFEEAB6960B3AABE60004
6B68642C59BBFC2F34DB60DBDFB2       0EC675AD498AFEEAB6960B3AABE60005
Authors' Addresses (Authors' Addresses)
```

Questions and comments should be directed to the authors and avt@ietf.org:
Questions and comments should be directed to the authors and avt@ietf.org:

Mark Baugher Cisco Systems, Inc. 5510 SW Orchid Street Portland, OR 97219 USA
Mark Baugher Cisco Systems, Inc. 5510 SW Orchid Street Portland, OR 97219 USA

Phone: +1 408-853-4418
Phone: +1 408-853-4418

EMail: mbaugher@cisco.com
EMail: mbaugher@cisco.com

Elisabetta Carrara Ericsson Research SE-16480 Stockholm Sweden
Elisabetta Carrara Ericsson Research SE-16480 Stockholm Sweden

Phone: +46 8 50877040
Phone: +46 8 50877040

EMail: elisabetta.carrara@ericsson.com
EMail: elisabetta.carrara@ericsson.com

David A. McGrew Cisco Systems, Inc. San Jose, CA 95134-1706 USA
David A. McGrew Cisco Systems, Inc. San Jose, CA 95134-1706 USA

Phone: +1 301-349-5815
Phone: +1 301-349-5815

EMail: mcgrew@cisco.com
EMail: mcgrew@cisco.com

Mats Naslund Ericsson Research SE-16480 Stockholm Sweden
Mats Naslund Ericsson Research SE-16480 Stockholm Sweden

Phone: +46 8 58533739
Phone: +46 8 58533739

EMail: mats.naslund@ericsson.com
EMail: mats.naslund@ericsson.com

Karl Norrman Ericsson Research SE-16480 Stockholm Sweden
Karl Norrman Ericsson Research SE-16480 Stockholm Sweden

Phone: +46 8 4044502
Phone: +46 8 4044502

EMail: karl.norrman@ericsson.com
EMail: karl.norrman@ericsson.com

## Full Copyright Statement (Full Copyright Statement)

Copyright (C) The Internet Society (2004). This document is subject to the rights, licenses and restrictions contained in BCP 78 and except as set forth therein, the authors retain all their rights.
Copyright (C) The Internet Society (2004). This document is subject to the rights, licenses and restrictions contained in BCP 78 and except as set forth therein, the authors retain all their rights.

This document and the information contained herein are provided on an "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
This document and the information contained herein are provided on an "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

## Intellectual Property (Intellectual Property)

The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.
The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.

Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.
Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.

The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf- ipr@ietf.org.
The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf- ipr@ietf.org.

## Acknowledgement (Acknowledgement)

Funding for the RFC Editor function is currently provided by the Internet Society.
Funding for the RFC Editor function is currently provided by the Internet Society.
