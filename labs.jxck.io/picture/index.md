# WebP と SVG の採用および PNG/JEPG 最適化戦略

## Intro

画像は Web におけるコンテンツの中でも支配的なサイズになるため、画像周りの最適化は非常に重要になる。

特に、その画像の用途に応じて以下を考慮しながら、適したものを配布していく必要がある。

- フォーマット
- サイズ
- 指定方法


本サイトでは、通常の PNG/JPEG の最適化に加え、 SVG と WebP を積極的に使用していく方針をたてている。
今回は、そうした本サイトで実施している画像の最適化戦略の現状を紹介する。


# フォーマット

本サイトでは、以下のフォーマットを用途に応じて使い分ける。

- svg
- png
- jpeg
- gif
- webp


## SVG

アイコンなどの UI ツールチップには  PNG なども使われるが、このサイトでは基本的に SVG を利用している。

ベクタフォーマットにすることで、画面サイズや拡大率などに関わらず、なめらかな画像を表示することができる。

またソースとなる XML は、パスを指定するテキストであるため、 gzip 圧縮も合わせれば、大きな画像を少ない情報で表せる場合が多い。


### 手書き SVG

筆者はイラレなどを持ってないため、本サイトの画像は基本的に [cacoo](https://cacoo.com/) を使って作っており、 cacoo は SVG 書き出しにも対応している。

しかし、ツールなどで書いた SVG のソースは、複雑なパスになったり、不要なメタ情報が付与されたりと、見た目が変わらないにも関わらずサイズが肥大する場合がある。

こうした無駄なものを削除するツールはあるが、このサイトで言えば右上の RSS, AMP のアイコンなどの単純なものは、サイズが小さくなるように手書きで作成した。

ここまでに手書きした SVG アイコンは、以下にソースとともに掲載している。


[SVG Gallery](http://labs.jxck.io/svg/)


### Font

SVG ではないが、フォントもベクタデータである。単色しか塗れないという制限もあるが、フォントの記号をアイコンとして使うこともある。

代表例が [Font-Awesome](https://fortawesome.github.io/Font-Awesome/) だが、本サイトでは使っていない。

もう一つ、 CSS の `content:` 要素でフォントを指定することもできる。

このサイトは見た目が Markdown ライクになるように CSS を作っている。

装飾に使用される `#` や `-` などの文字は、 `before`/`after` 擬似要素への `content:` に文字を指定することで、フォントデータを使って装飾している。

WebFont を利用しない場合は、マシンローカルのベクタデータを流用していることになるため、画像転送のオーバーヘッドも無くなる。


## WebP

PNG, JPEG 両方の用途で代替として検討できる。

このフォーマットを使うことで、画質を犠牲にせずかなりのサイズ削減が期待できる。

WebP アニメーションを使えば、 GIF アニメよりも色数が多く綺麗なアニメーションを作ることができる。

WebP は WebM の1フレームが基本なため、つまり WebP アニメーションは簡易 WebM と言っても良い。スクリーンシェアなどに使用しやすいだろう。

しかし対応してないブラウザのためには代替として PNG, JPEG などにフォールバックできるように、後述の srcset で選択肢として提示し、ブラウザに選ばせている。


## サイズ戦略

画像において最も無駄なのは、サイズの大きい画像を小さく表示している場合である。

これはネットワークでの転送上も、ブラウザのレンダリング上もオーバーヘッドになる。

サイズが大きいということはデータが多いため、リサイズして表示するサイズぴったりに加工できればデータ量も最適となる。

また、見た目上の劣化が生じなければ減色や、余計なメタ情報の削除などの最適化も考えられる。


### メタ情報削除

画像には位置情報やカラープロファイルなどのメタ情報が内包されている場合がある。
これらの情報が不要であれば消してしまうことで、データを削減できる。

そのためのツールはいくつかあるが、有名どころでは以下がある。

- [ImageOptim](https://imageoptim.com)


### 減色

一点の色の情報を 24bit で表しているものを、例えば 8bit に変換することで、表現できる色の数を減らす代わりにデータ量も減らす。
例えばレコードを CD にしたような変化になるが、そもそも Full Bitmap で表現したいという訳でない限り(lossy format 使ってるなら特に)気にならない範囲で行う。

- [TinyPNG](https://tinypng.com/) (JPEG も対応している)
- [ImageAlpha](https://pngmini.com/)
- [JPEGMini](http://www.jpegmini.com/) (有料)
- [pngquant](http://pngquant.org/) (CLI)


### 縮小

PC ブラウザを対象にするのであれば、基本的には表示するピクセルサイズにリサイズすれば良い。
問題はモバイルのブラウザの挙動にある。



## ベースライン/プログレッシブ

JPEG は、大きい画像を送信する際に、ベースとなるデータを先に送り、差分となるデータをあとから追加して画像を完成させることができる。

- ベースライン: 画像を上から順番に表示していく
- プログレッシブ: 解像度の低い画像から表示され、徐々に鮮明になっていく

なお、 PNG はベースラインではなくインタレースと呼ばれる。

どちらを使うかは、二つの観点がある。

- どちらのサイズが小さいか
- UX としてどちらが良いか


### サイズ

まず、前者のサイズについて、少し古いが Steve 先生の調査がある。

http://yuiblog.com/blog/2008/12/05/imageopt-4/

あらゆる画像を二つの形式で保存した場合、サイズがそれぞれどうなるかを検証している。
結果だけ引用する。

> when your JPEG image is under 10K, it's better to be saved as baseline JPEG (estimated 75% chance it will be smaller)
  for files over 10K the progressive JPEG will give you a better compression (in 94% of the cases)

素材のサイズが 10K を超えるかどうかで結果が変わるそうだ。そして必ずではないので、実際に両方で保存してみて試すしかない。


### UX

後者の UX だが、細い回線で大きめの画像を表示した際、ユーザがどう感じるか、という点がある。

まず、個人的には同じサイトでも、サイズによってロードの仕方が変わるのはあまり好ましくないと感じる。

そして、このサイトでは JPEG 以外にも PNG/WebP/SVG を使う。

全ての挙動をなるべく近づけるには、サイズに限らずベースラインに統一するのが良さそうと判断した。

(あと、プログレッシブはなんか古臭いというか、ダサく感じるのは自分だけだろうか)


## 最適イメージの出し分け

サイズ・フォーマット的に最適なイメージは、クライアントによって変わる。
具体的には、現状以下の分岐を考慮する必要がある。

- WebP に対応しているか(ブラウザの分岐)
- ViewPort Size はいくつか(端末サイズの分岐)
- DPI はいくつか(retina 対応)


### WebP 対応

これまでは写真=JPEG, アイコン=PNG, アニメ=GIF といった使い分けがなされていたが、もし対応しているのであれば、これら全て WebP に集約可能であり、その方がサイズ的に有利な場合が多い。

しかし、 [WebP の対応はまだまだ限定的](http://caniuse.com/#feat=webp) であるため、過去の記事では UA を元にしたサーバ側での出し分けの方法などが紹介されている。

しかし、 UA での分岐は避けるべきパターンの一つであり、なによりスケールしにくい。

一方、 HTML の `<picture>` や `srcset` を用いることで、ブラウザ自体にそれを判断させることができるため、こちらの方法が望ましい。
( [picture](http://caniuse.com/#search=picture), [srcset](http://caniuse.com/#search=srcset) に対応していない古いブラウザは、そもそも WebP に対応していない)


### Picture

`<picture>` には様々な条件を指定することができるが、 `type` を用いることでフォーマットの指定も可能である。

画像の指定を以下のように指定することで、対応ブラウザが自ら WebP をリクエストするようになり、 WebP や `<picture>` に対応していない場合は `<img>` に指定した画像にフォールバックする。

<picture>
  <source type=image/webp srcset=hero-image.webp>
  <img src=hero-image.png alt="hero image">
</picture>


### サイズ最適化

PNG/JPEG などのラスタ形式画像において、サイズとは基本的に縦横に敷き詰められた正方形の数を指す。
100x100 個の正方形でなる画像は、 100x100 で表示すれば基本的には問題ない。
しかし、 200x200 で表示すれば、同じ正方形を縦横二つ並べて大きくしないといけないため、鮮明さが落ちる。

もし画像の綺麗さに対して敏感な人が作れば、基本的に縦長なモバイル端末を横に倒した時は、表示している画像を拡大するのではなく、大きな画像に置き換えたいと思うかもしれない。

ただし、表示の大きさはスクリーンの大きさと必ずしも比例しない。
Retina ディスプレイは、通常のスクリーンよりも、スクリーン上に並ぶ正方形が小さいサイズになっている。
スクリーンが持つ 1x1 を描画するための四角は **device pixel** といい、これが小ほど **画面密度(device pixel ratio)** が高いと表現する。

`x2` という解像度であれば、 100x100 を素直に表示すると、同じスクリーンサイズの非 Retina ディスプレイで表示した時の 50x50 の見た目になってしまう。
よって、 Retina を持つ端末は、実際に自分が持っている **device pixel** と、 CSS で指定する **css pixel** を分けることにした。
つまり、 css で 100x100 (css pixel)で表示するように指定された画像は、勝手に 200x200 (device pixel)に拡大して表示することで、製作者が想定する **描画サイズ(見た目の大きさ)** になるようにしている。

ところが、サイズが良くても解像度は前述と同じ理由で荒くなる。
そのため、 Retina に対応するためには、あらかじめ 200x200 で作った画像も用意し、出し分ける必要がある。
今では `x3` の端末もあるため、 300x300 の画像も必要になる。将来的にこれが増えていく可能性もゼロではないだろう。

逆に、大きいサイズの画像を小さく表示する分には、見た目上の問題は通常無い。
従って、 300x300 を用意しておき、相手がだれであろうとそれを送って、 200x200 なり 100x100 なり都合の良いサイズで表示してもらえば、 **見た目の問題** は解決する。

しかし、 100x100 のデータ必要な端末に 300x300 の画像を送るのは単純に無駄だ。
単純計算で、本来必要なデータの 9 倍近いデータを送ることになる。

最適な画像を出し分けるのは、大事な一方、実は非常に複雑なのだ。


## 対応方法

今回は、デバイスのサイズや解像度などに応じて、適切なサイズの画像を出し分けられるようにする設定を考える。

特に、複雑なインタラクションは考えない。




加えて、例えばデバイスを横に持ってワイドスクリーンになった場合に、画像を大きくしたいなどとなれば、必要なサイズはまた変わるだろう。

























|    format |   size |
|:----------|-------:|
| jxck.png  |   3.8K |
| jxck.webp |   1.8K |
| jxck.svg  |   291B |

